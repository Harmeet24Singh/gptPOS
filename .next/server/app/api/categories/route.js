"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/categories/route";
exports.ids = ["app/api/categories/route"];
exports.modules = {

/***/ "mongodb":
/*!**************************!*\
  !*** external "mongodb" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("mongodb");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcategories%2Froute&page=%2Fapi%2Fcategories%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcategories%2Froute.js&appDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcategories%2Froute&page=%2Fapi%2Fcategories%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcategories%2Froute.js&appDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_shop_Desktop_gptPos_gptPOS_app_api_categories_route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/categories/route.js */ \"(rsc)/./app/api/categories/route.js\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/categories/route\",\n        pathname: \"/api/categories\",\n        filename: \"route\",\n        bundlePath: \"app/api/categories/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\shop\\\\Desktop\\\\gptPos\\\\gptPOS\\\\app\\\\api\\\\categories\\\\route.js\",\n    nextConfigOutput,\n    userland: C_Users_shop_Desktop_gptPos_gptPOS_app_api_categories_route_js__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/categories/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjYXRlZ29yaWVzJTJGcm91dGUmcGFnZT0lMkZhcGklMkZjYXRlZ29yaWVzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGY2F0ZWdvcmllcyUyRnJvdXRlLmpzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNzaG9wJTVDRGVza3RvcCU1Q2dwdFBvcyU1Q2dwdFBPUyU1Q2FwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9QyUzQSU1Q1VzZXJzJTVDc2hvcCU1Q0Rlc2t0b3AlNUNncHRQb3MlNUNncHRQT1MmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ3dCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udmVuaWVuY2Utc3RvcmUtaW52ZW50b3J5Lz9mN2JlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXHNob3BcXFxcRGVza3RvcFxcXFxncHRQb3NcXFxcZ3B0UE9TXFxcXGFwcFxcXFxhcGlcXFxcY2F0ZWdvcmllc1xcXFxyb3V0ZS5qc1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvY2F0ZWdvcmllcy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2NhdGVnb3JpZXNcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2NhdGVnb3JpZXMvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxzaG9wXFxcXERlc2t0b3BcXFxcZ3B0UG9zXFxcXGdwdFBPU1xcXFxhcHBcXFxcYXBpXFxcXGNhdGVnb3JpZXNcXFxccm91dGUuanNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2NhdGVnb3JpZXMvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcategories%2Froute&page=%2Fapi%2Fcategories%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcategories%2Froute.js&appDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/categories/route.js":
/*!*************************************!*\
  !*** ./app/api/categories/route.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELETE: () => (/* binding */ DELETE),\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _server_mongo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../server/mongo */ \"(rsc)/./server/mongo.js\");\n/* harmony import */ var _server_mongo__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_server_mongo__WEBPACK_IMPORTED_MODULE_1__);\n\n\nasync function GET() {\n    try {\n        const categories = await (0,_server_mongo__WEBPACK_IMPORTED_MODULE_1__.getCategories)();\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(categories);\n    } catch (error) {\n        console.error(\"Failed to get categories:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to fetch categories\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function POST(request) {\n    try {\n        const category = await request.json();\n        if (!category.name) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Category name is required\"\n            }, {\n                status: 400\n            });\n        }\n        const result = await (0,_server_mongo__WEBPACK_IMPORTED_MODULE_1__.saveCategory)(category);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        console.error(\"Failed to save category:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to save category\"\n        }, {\n            status: 500\n        });\n    }\n}\nasync function DELETE(request) {\n    try {\n        const { searchParams } = new URL(request.url);\n        const id = searchParams.get(\"id\");\n        if (!id) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Category ID is required\"\n            }, {\n                status: 400\n            });\n        }\n        const result = await (0,_server_mongo__WEBPACK_IMPORTED_MODULE_1__.deleteCategory)(id);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        console.error(\"Failed to delete category:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to delete category\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2NhdGVnb3JpZXMvcm91dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJDO0FBQ3lDO0FBRTdFLGVBQWVJO0lBQ3BCLElBQUk7UUFDRixNQUFNQyxhQUFhLE1BQU1KLDREQUFhQTtRQUN0QyxPQUFPRCxxREFBWUEsQ0FBQ00sSUFBSSxDQUFDRDtJQUMzQixFQUFFLE9BQU9FLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsT0FBT1AscURBQVlBLENBQUNNLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQTZCLEdBQUc7WUFBRUUsUUFBUTtRQUFJO0lBQ2xGO0FBQ0Y7QUFFTyxlQUFlQyxLQUFLQyxPQUFPO0lBQ2hDLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1ELFFBQVFMLElBQUk7UUFFbkMsSUFBSSxDQUFDTSxTQUFTQyxJQUFJLEVBQUU7WUFDbEIsT0FBT2IscURBQVlBLENBQUNNLElBQUksQ0FBQztnQkFBRUMsT0FBTztZQUE0QixHQUFHO2dCQUFFRSxRQUFRO1lBQUk7UUFDakY7UUFFQSxNQUFNSyxTQUFTLE1BQU1aLDJEQUFZQSxDQUFDVTtRQUNsQyxPQUFPWixxREFBWUEsQ0FBQ00sSUFBSSxDQUFDUTtJQUMzQixFQUFFLE9BQU9QLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBT1AscURBQVlBLENBQUNNLElBQUksQ0FBQztZQUFFQyxPQUFPO1FBQTBCLEdBQUc7WUFBRUUsUUFBUTtRQUFJO0lBQy9FO0FBQ0Y7QUFFTyxlQUFlTSxPQUFPSixPQUFPO0lBQ2xDLElBQUk7UUFDRixNQUFNLEVBQUVLLFlBQVksRUFBRSxHQUFHLElBQUlDLElBQUlOLFFBQVFPLEdBQUc7UUFDNUMsTUFBTUMsS0FBS0gsYUFBYUksR0FBRyxDQUFDO1FBRTVCLElBQUksQ0FBQ0QsSUFBSTtZQUNQLE9BQU9uQixxREFBWUEsQ0FBQ00sSUFBSSxDQUFDO2dCQUFFQyxPQUFPO1lBQTBCLEdBQUc7Z0JBQUVFLFFBQVE7WUFBSTtRQUMvRTtRQUVBLE1BQU1LLFNBQVMsTUFBTVgsNkRBQWNBLENBQUNnQjtRQUNwQyxPQUFPbkIscURBQVlBLENBQUNNLElBQUksQ0FBQ1E7SUFDM0IsRUFBRSxPQUFPUCxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU9QLHFEQUFZQSxDQUFDTSxJQUFJLENBQUM7WUFBRUMsT0FBTztRQUE0QixHQUFHO1lBQUVFLFFBQVE7UUFBSTtJQUNqRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29udmVuaWVuY2Utc3RvcmUtaW52ZW50b3J5Ly4vYXBwL2FwaS9jYXRlZ29yaWVzL3JvdXRlLmpzP2Q0MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XHJcbmltcG9ydCB7IGdldENhdGVnb3JpZXMsIHNhdmVDYXRlZ29yeSwgZGVsZXRlQ2F0ZWdvcnkgfSBmcm9tIFwiLi4vLi4vLi4vc2VydmVyL21vbmdvXCI7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjYXRlZ29yaWVzID0gYXdhaXQgZ2V0Q2F0ZWdvcmllcygpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKGNhdGVnb3JpZXMpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGdldCBjYXRlZ29yaWVzOlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZmV0Y2ggY2F0ZWdvcmllc1wiIH0sIHsgc3RhdHVzOiA1MDAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNhdGVnb3J5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICBcclxuICAgIGlmICghY2F0ZWdvcnkubmFtZSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJDYXRlZ29yeSBuYW1lIGlzIHJlcXVpcmVkXCIgfSwgeyBzdGF0dXM6IDQwMCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYXZlQ2F0ZWdvcnkoY2F0ZWdvcnkpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3VsdCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBjYXRlZ29yeTpcIiwgZXJyb3IpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IFwiRmFpbGVkIHRvIHNhdmUgY2F0ZWdvcnlcIiB9LCB7IHN0YXR1czogNTAwIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIERFTEVURShyZXF1ZXN0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcclxuICAgIGNvbnN0IGlkID0gc2VhcmNoUGFyYW1zLmdldCgnaWQnKTtcclxuICAgIFxyXG4gICAgaWYgKCFpZCkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJDYXRlZ29yeSBJRCBpcyByZXF1aXJlZFwiIH0sIHsgc3RhdHVzOiA0MDAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVsZXRlQ2F0ZWdvcnkoaWQpO1xyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3VsdCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIGNhdGVnb3J5OlwiLCBlcnJvcik7XHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogXCJGYWlsZWQgdG8gZGVsZXRlIGNhdGVnb3J5XCIgfSwgeyBzdGF0dXM6IDUwMCB9KTtcclxuICB9XHJcbn0iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiZ2V0Q2F0ZWdvcmllcyIsInNhdmVDYXRlZ29yeSIsImRlbGV0ZUNhdGVnb3J5IiwiR0VUIiwiY2F0ZWdvcmllcyIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJzdGF0dXMiLCJQT1NUIiwicmVxdWVzdCIsImNhdGVnb3J5IiwibmFtZSIsInJlc3VsdCIsIkRFTEVURSIsInNlYXJjaFBhcmFtcyIsIlVSTCIsInVybCIsImlkIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/categories/route.js\n");

/***/ }),

/***/ "(rsc)/./server/mongo.js":
/*!*************************!*\
  !*** ./server/mongo.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { MongoClient } = __webpack_require__(/*! mongodb */ \"mongodb\");\nconst url = process.env.MONGO_URI || \"mongodb://localhost:27017\";\nconst dbName = process.env.MONGO_DB || \"convenience_store\";\nlet _client = null;\nlet _db = null;\nasync function connect() {\n    if (_db) return _db;\n    if (!_client) {\n        _client = new MongoClient(url, {\n            useUnifiedTopology: true\n        });\n        await _client.connect();\n    }\n    _db = _client.db(dbName);\n    // Ensure indexes\n    try {\n        await _db.collection(\"inventory\").createIndex({\n            id: 1\n        }, {\n            unique: true\n        });\n        await _db.collection(\"users\").createIndex({\n            id: 1\n        }, {\n            unique: true,\n            sparse: true\n        });\n        await _db.collection(\"users\").createIndex({\n            username: 1\n        }, {\n            unique: true\n        });\n    } catch (e) {\n    // ignore index errors\n    }\n    return _db;\n}\n// Inventory helpers\nasync function getAllInventory() {\n    const db = await connect();\n    return db.collection(\"inventory\").find({}).sort({\n        name: 1\n    }).toArray();\n}\nasync function getInventoryById(id) {\n    const db = await connect();\n    const n = Number(id);\n    return db.collection(\"inventory\").findOne({\n        id: n\n    });\n}\nasync function upsertInventoryItems(items) {\n    if (!Array.isArray(items)) items = [\n        items\n    ];\n    console.log(\"upsertInventoryItems called with:\", items.length, \"items\");\n    const db = await connect();\n    const ops = items.map((it, index)=>{\n        console.log(`Processing item ${index} for upsert:`, JSON.stringify(it, null, 2));\n        // Validate and convert ID\n        let itemId = undefined;\n        if (it.id !== undefined && it.id !== null) {\n            itemId = Number(it.id);\n            if (isNaN(itemId)) {\n                console.error(`Invalid ID for item ${index}:`, it.id);\n                throw new Error(`Invalid ID: ${it.id}`);\n            }\n            console.log(`Item ${index} has valid numeric ID:`, itemId);\n        } else {\n            console.log(`Item ${index} has no ID, will be auto-generated`);\n        }\n        const obj = {\n            id: itemId,\n            name: it.name || \"\",\n            category: it.category || \"\",\n            price: Number(it.price || 0),\n            stock: Number(it.stock || 0),\n            lowStockThreshold: Number(it.lowStockThreshold || 0),\n            taxable: !!it.taxable,\n            barcode: it.barcode || (itemId ? itemId.toString() : null)\n        };\n        // Add barcode2 if provided\n        if (it.barcode2) {\n            obj.barcode2 = it.barcode2;\n        }\n        // Only add productId if it's provided, to avoid null constraint issues\n        if (it.productId) {\n            obj.productId = it.productId;\n        } else if (itemId) {\n            obj.productId = itemId.toString(); // Use ID as productId for new items\n        }\n        // Validate required fields\n        if (!obj.name) {\n            throw new Error(`Item name is required for item ${index}`);\n        }\n        // remove undefined id to let upsert use provided id or create one\n        if (obj.id === undefined) delete obj.id;\n        const filter = obj.id !== undefined ? {\n            id: obj.id\n        } : {\n            name: obj.name\n        };\n        console.log(`=== MONGODB UPSERT OPERATION ${index} ===`);\n        console.log(\"Filter:\", JSON.stringify(filter, null, 2));\n        console.log(\"Update document:\", JSON.stringify(obj, null, 2));\n        console.log(`Item ${index} filter:`, filter);\n        console.log(`Item ${index} object:`, obj);\n        return {\n            updateOne: {\n                filter,\n                update: {\n                    $set: obj\n                },\n                upsert: true\n            }\n        };\n    });\n    if (ops.length === 0) {\n        console.log(\"No operations to perform\");\n        return;\n    }\n    console.log(\"Executing bulkWrite with\", ops.length, \"operations\");\n    try {\n        const result = await db.collection(\"inventory\").bulkWrite(ops);\n        console.log(\"BulkWrite result:\", result);\n    } catch (error) {\n        console.error(\"BulkWrite error:\", error);\n        // If it's a duplicate key error on productId, try to handle it gracefully\n        if (error.code === 11000 && error.message.includes(\"productId\")) {\n            console.log(\"Detected productId duplicate key error, attempting individual upserts...\");\n            // Try each item individually with unique productId generation\n            for(let i = 0; i < items.length; i++){\n                const item = items[i];\n                try {\n                    const itemWithUniqueProductId = {\n                        ...item,\n                        productId: item.productId || `${item.id || Date.now()}-${i}`\n                    };\n                    const filter = item.id ? {\n                        id: item.id\n                    } : {\n                        name: item.name\n                    };\n                    await db.collection(\"inventory\").updateOne(filter, {\n                        $set: itemWithUniqueProductId\n                    }, {\n                        upsert: true\n                    });\n                    console.log(`Successfully upserted item ${i} with unique productId`);\n                } catch (individualError) {\n                    console.error(`Failed to upsert individual item ${i}:`, individualError);\n                    throw individualError;\n                }\n            }\n            console.log(\"All items processed successfully via individual upserts\");\n            return;\n        }\n        throw error;\n    }\n}\nasync function deleteInventoryById(id) {\n    const db = await connect();\n    const n = Number(id);\n    await db.collection(\"inventory\").deleteOne({\n        id: n\n    });\n}\n// Users helpers\nasync function getUsers() {\n    const db = await connect();\n    const users = await db.collection(\"users\").find({}).sort({\n        id: 1\n    }).toArray();\n    // Auto-create default users if no users exist\n    if (users.length === 0) {\n        console.log(\"No users found. Creating default admin and cashier users...\");\n        const defaultUsers = [\n            {\n                id: \"admin\",\n                pwd: \"admin123\",\n                role: \"Admin\",\n                email: \"admin@pos.local\",\n                active: true,\n                permissions_json: JSON.stringify({\n                    inventory: true,\n                    users: true,\n                    reports: true,\n                    pos: true,\n                    transactions: true,\n                    manageUsers: true,\n                    manageInventory: true,\n                    manageReports: true,\n                    managePOS: true\n                })\n            },\n            {\n                id: \"cashier\",\n                pwd: \"cashier1\",\n                role: \"Cashier\",\n                email: \"cashier@pos.local\",\n                active: true,\n                permissions_json: JSON.stringify({\n                    inventory: false,\n                    users: false,\n                    reports: false,\n                    pos: true,\n                    transactions: false,\n                    manageUsers: false,\n                    manageInventory: false,\n                    manageReports: false,\n                    managePOS: true\n                })\n            }\n        ];\n        try {\n            await db.collection(\"users\").insertMany(defaultUsers);\n            console.log(\"âœ… Default users created:\");\n            console.log(\"   - Admin: username=admin, password=admin123\");\n            console.log(\"   - Cashier: username=cashier, password=cashier1\");\n        } catch (error) {\n            console.error(\"Failed to create default users:\", error);\n        }\n        const newUsers = await db.collection(\"users\").find({}).sort({\n            id: 1\n        }).toArray();\n        return newUsers.map((user)=>({\n                ...user,\n                username: user.id || user.username,\n                password: user.pwd || user.password || \"\"\n            }));\n    }\n    // Map database fields to frontend expected fields\n    return users.map((user)=>({\n            ...user,\n            username: user.id,\n            password: user.pwd || user.password // Map pwd to password for frontend\n        }));\n}\nasync function getUserByUsername(username) {\n    const db = await connect();\n    // Try to find user by id first, then by username field if it exists\n    let user = await db.collection(\"users\").findOne({\n        id: username\n    });\n    if (!user) {\n        user = await db.collection(\"users\").findOne({\n            username: username\n        });\n    }\n    if (user) {\n        // Map database fields to frontend expected fields\n        return {\n            ...user,\n            username: user.id || user.username,\n            password: user.pwd || user.password || \"\"\n        };\n    }\n    return null;\n}\nasync function upsertUser(body) {\n    const db = await connect();\n    const id = body.id || body.username;\n    await db.collection(\"users\").updateOne({\n        id\n    }, {\n        $set: {\n            id,\n            email: body.email || \"\",\n            pwd: body.password || body.pwd || \"\",\n            role: body.role || \"user\",\n            active: body.active !== false,\n            permissions_json: JSON.stringify(body.permissions || {})\n        }\n    }, {\n        upsert: true\n    });\n}\nasync function replaceAllUsers(users) {\n    const db = await connect();\n    // Clear existing users and insert new ones\n    await db.collection(\"users\").deleteMany({});\n    if (users.length > 0) {\n        const formattedUsers = users.map((user)=>({\n                id: user.id || user.username,\n                email: user.email || \"\",\n                pwd: user.password || user.pwd || \"\",\n                role: user.role || \"user\",\n                active: user.active !== false,\n                permissions_json: JSON.stringify(user.permissions || {})\n            }));\n        await db.collection(\"users\").insertMany(formattedUsers);\n    }\n}\nasync function deleteUserById(id) {\n    const db = await connect();\n    // Prevent deletion of admin users (super role protection)\n    const user = await db.collection(\"users\").findOne({\n        id: id\n    });\n    if (user && (user.role === \"admin\" || user.role === \"Admin\" || user.id === \"admin\")) {\n        throw new Error(\"Admin users cannot be deleted - this is a protected super role\");\n    }\n    await db.collection(\"users\").deleteOne({\n        id: id\n    });\n}\n// Transactions helpers\nasync function saveTransaction(txObj) {\n    const db = await connect();\n    // Determine transaction type based on payment breakdown\n    const paymentBreakdown = txObj.paymentBreakdown || txObj.payment || [];\n    let transactionType = \"mixed\"; // default\n    let cashAmount = 0;\n    let cardAmount = 0;\n    let creditAmount = 0;\n    // Calculate payment amounts by method\n    let hasLotto = false;\n    paymentBreakdown.forEach((payment)=>{\n        const amount = Number(payment.amount || 0);\n        switch(payment.method?.toLowerCase()){\n            case \"cash\":\n                cashAmount += amount;\n                break;\n            case \"card\":\n                cardAmount += amount;\n                break;\n            case \"credit\":\n                creditAmount += amount;\n                break;\n            case \"lotto\":\n                hasLotto = true;\n                break;\n        }\n    });\n    // Determine primary transaction type\n    if (hasLotto && cashAmount < 0 && cardAmount === 0 && creditAmount === 0) {\n        // Lotto-only transaction (cash going out)\n        transactionType = \"lotto\";\n    } else if (creditAmount > 0) {\n        if (cashAmount > 0 || cardAmount > 0) {\n            transactionType = \"partial_credit\";\n        } else {\n            transactionType = \"credit\";\n        }\n    } else if (cashAmount > 0 && cardAmount > 0) {\n        transactionType = \"mixed\";\n    } else if (cashAmount > 0) {\n        transactionType = \"cash\";\n    } else if (cardAmount > 0) {\n        transactionType = \"card\";\n    } else if (hasLotto) {\n        // Lotto with other payments\n        transactionType = \"lotto_mixed\";\n    }\n    // normalize timestamp\n    const doc = {\n        legacy_id: txObj.id || null,\n        timestamp: txObj.timestamp ? new Date(txObj.timestamp) : new Date(),\n        subtotal: Number(txObj.subtotal || 0),\n        taxableAmount: Number(txObj.taxableAmount || 0),\n        nonTaxableAmount: Number(txObj.nonTaxableAmount || 0),\n        tax: Number(txObj.tax || 0),\n        total: Number(txObj.total || 0),\n        cashback: Number(txObj.cashback || 0),\n        paymentBreakdown: paymentBreakdown,\n        change: Number(txObj.change || 0),\n        transactionType: transactionType,\n        cashAmount: cashAmount,\n        cardAmount: cardAmount,\n        creditAmount: creditAmount,\n        items: Array.isArray(txObj.items) ? txObj.items.map((it)=>({\n                product_id: it.id || null,\n                name: it.name || \"\",\n                quantity: Number(it.quantity || 0),\n                price: Number(it.price || 0),\n                applyTax: !!it.applyTax\n            })) : []\n    };\n    const res = await db.collection(\"transactions\").insertOne(doc);\n    const insertedId = res.insertedId;\n    // Deduct stock for each item (best-effort)\n    for (const it of doc.items){\n        if (!it.product_id) continue;\n        const cur = await db.collection(\"inventory\").findOne({\n            id: Number(it.product_id)\n        });\n        if (cur) {\n            const newStock = (cur.stock || 0) - (it.quantity || 0);\n            await db.collection(\"inventory\").updateOne({\n                id: Number(it.product_id)\n            }, {\n                $set: {\n                    stock: newStock\n                }\n            });\n        }\n    }\n    return insertedId;\n}\nasync function getTransactions(limit = 100) {\n    const db = await connect();\n    const cursor = db.collection(\"transactions\").find({}).sort({\n        _id: -1\n    }).limit(Number(limit));\n    const rows = await cursor.toArray();\n    return rows.map((r)=>({\n            ...r,\n            id: r._id.toString(),\n            timestamp: r.timestamp instanceof Date ? r.timestamp.toISOString() : r.timestamp\n        }));\n}\nasync function deleteTransaction(id) {\n    const db = await connect();\n    const { ObjectId } = __webpack_require__(/*! mongodb */ \"mongodb\");\n    try {\n        // Convert string ID to ObjectId for MongoDB\n        const objectId = new ObjectId(id);\n        const result = await db.collection(\"transactions\").deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting transaction:\", error);\n        return false;\n    }\n}\n// Categories helpers\nasync function getCategories() {\n    const db = await connect();\n    const categories = await db.collection(\"categories\").find({}).sort({\n        name: 1\n    }).toArray();\n    // If no categories exist, create default ones\n    if (categories.length === 0) {\n        const defaultCategories = [\n            {\n                id: 1,\n                name: \"Beverages\",\n                description: \"Soft drinks, energy drinks, water, and other beverages\"\n            },\n            {\n                id: 2,\n                name: \"Snacks\",\n                description: \"Chips, crackers, nuts, and other snack foods\"\n            },\n            {\n                id: 3,\n                name: \"Bakery\",\n                description: \"Bread, pastries, and baked goods\"\n            },\n            {\n                id: 4,\n                name: \"Tobacco\",\n                description: \"Cigarettes and tobacco products\"\n            },\n            {\n                id: 5,\n                name: \"Dairy\",\n                description: \"Milk, cheese, yogurt, and dairy products\"\n            },\n            {\n                id: 6,\n                name: \"Frozen Foods\",\n                description: \"Ice cream, frozen meals, and frozen items\"\n            },\n            {\n                id: 7,\n                name: \"Personal Care\",\n                description: \"Toiletries, hygiene, and personal care items\"\n            },\n            {\n                id: 8,\n                name: \"Household\",\n                description: \"Cleaning supplies, paper products, and household items\"\n            },\n            {\n                id: 9,\n                name: \"Fresh Produce\",\n                description: \"Fruits, vegetables, and fresh produce\"\n            },\n            {\n                id: 10,\n                name: \"Candy\",\n                description: \"Chocolates, gums, and sweet treats\"\n            }\n        ];\n        await db.collection(\"categories\").insertMany(defaultCategories);\n        return defaultCategories;\n    }\n    return categories;\n}\nasync function saveCategory(category) {\n    const db = await connect();\n    if (category.id) {\n        // Update existing category\n        const result = await db.collection(\"categories\").updateOne({\n            id: Number(category.id)\n        }, {\n            $set: {\n                name: category.name,\n                description: category.description || \"\",\n                updatedAt: new Date()\n            }\n        }, {\n            upsert: true\n        });\n        return {\n            id: category.id,\n            ...category\n        };\n    } else {\n        // Create new category - find next available ID\n        const lastCategory = await db.collection(\"categories\").findOne({}, {\n            sort: {\n                id: -1\n            }\n        });\n        const nextId = (lastCategory?.id || 0) + 1;\n        const newCategory = {\n            id: nextId,\n            name: category.name,\n            description: category.description || \"\",\n            createdAt: new Date(),\n            updatedAt: new Date()\n        };\n        await db.collection(\"categories\").insertOne(newCategory);\n        return newCategory;\n    }\n}\nasync function deleteCategory(id) {\n    const db = await connect();\n    const result = await db.collection(\"categories\").deleteOne({\n        id: Number(id)\n    });\n    return result.deletedCount > 0;\n}\n// Credit Accounts helpers\nasync function getCreditAccounts() {\n    const db = await connect();\n    const cursor = db.collection(\"creditAccounts\").find({}).sort({\n        lastTransactionDate: -1\n    });\n    const accounts = await cursor.toArray();\n    return accounts.map((account)=>({\n            ...account,\n            id: account._id.toString(),\n            createdAt: account.createdAt instanceof Date ? account.createdAt.toISOString() : account.createdAt,\n            updatedAt: account.updatedAt instanceof Date ? account.updatedAt.toISOString() : account.updatedAt,\n            lastTransactionDate: account.lastTransactionDate instanceof Date ? account.lastTransactionDate.toISOString() : account.lastTransactionDate\n        }));\n}\nasync function getCreditAccountByName(customerName) {\n    const db = await connect();\n    const account = await db.collection(\"creditAccounts\").findOne({\n        customerName: {\n            $regex: new RegExp(\"^\" + customerName.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") + \"$\", \"i\")\n        }\n    });\n    if (!account) return null;\n    return {\n        ...account,\n        id: account._id.toString(),\n        createdAt: account.createdAt instanceof Date ? account.createdAt.toISOString() : account.createdAt,\n        updatedAt: account.updatedAt instanceof Date ? account.updatedAt.toISOString() : account.updatedAt,\n        lastTransactionDate: account.lastTransactionDate instanceof Date ? account.lastTransactionDate.toISOString() : account.lastTransactionDate\n    };\n}\nasync function upsertCreditAccount(accountData) {\n    const db = await connect();\n    const { ObjectId } = __webpack_require__(/*! mongodb */ \"mongodb\");\n    const now = new Date();\n    const customerName = accountData.customerName?.trim();\n    if (!customerName) {\n        throw new Error(\"Customer name is required\");\n    }\n    // Find existing account (case-insensitive)\n    const existingAccount = await db.collection(\"creditAccounts\").findOne({\n        customerName: {\n            $regex: new RegExp(\"^\" + customerName.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") + \"$\", \"i\")\n        }\n    });\n    if (existingAccount) {\n        // Update existing account\n        const updateData = {\n            balance: Number(accountData.balance || existingAccount.balance || 0),\n            phone: accountData.phone || existingAccount.phone || \"\",\n            email: accountData.email || existingAccount.email || \"\",\n            address: accountData.address || existingAccount.address || \"\",\n            notes: accountData.notes || existingAccount.notes || \"\",\n            isActive: accountData.isActive !== undefined ? accountData.isActive : existingAccount.isActive,\n            updatedAt: now\n        };\n        // Update last transaction date if provided\n        if (accountData.lastTransactionDate) {\n            updateData.lastTransactionDate = accountData.lastTransactionDate instanceof Date ? accountData.lastTransactionDate : new Date(accountData.lastTransactionDate);\n        }\n        // Update transaction count if provided\n        if (accountData.transactionCount !== undefined) {\n            updateData.transactionCount = Number(accountData.transactionCount);\n        }\n        const result = await db.collection(\"creditAccounts\").updateOne({\n            _id: existingAccount._id\n        }, {\n            $set: updateData\n        });\n        if (result.modifiedCount > 0) {\n            const updatedAccount = await db.collection(\"creditAccounts\").findOne({\n                _id: existingAccount._id\n            });\n            return {\n                ...updatedAccount,\n                id: updatedAccount._id.toString()\n            };\n        }\n        return {\n            ...existingAccount,\n            id: existingAccount._id.toString()\n        };\n    } else {\n        // Create new account\n        const newAccount = {\n            customerName: customerName,\n            balance: Number(accountData.balance || 0),\n            phone: accountData.phone || \"\",\n            email: accountData.email || \"\",\n            address: accountData.address || \"\",\n            notes: accountData.notes || \"\",\n            isActive: accountData.isActive !== undefined ? accountData.isActive : true,\n            transactionCount: Number(accountData.transactionCount || 0),\n            createdAt: now,\n            updatedAt: now,\n            lastTransactionDate: accountData.lastTransactionDate ? accountData.lastTransactionDate instanceof Date ? accountData.lastTransactionDate : new Date(accountData.lastTransactionDate) : now\n        };\n        const result = await db.collection(\"creditAccounts\").insertOne(newAccount);\n        return {\n            ...newAccount,\n            id: result.insertedId.toString()\n        };\n    }\n}\nasync function addToCreditAccount(customerName, amount, transactionId = null) {\n    const db = await connect();\n    // Get or create account\n    let account = await getCreditAccountByName(customerName);\n    if (!account) {\n        // Create new account if it doesn't exist\n        account = await upsertCreditAccount({\n            customerName: customerName,\n            balance: amount,\n            transactionCount: 1,\n            lastTransactionDate: new Date()\n        });\n    } else {\n        // Update existing account\n        const newBalance = Number(account.balance || 0) + Number(amount);\n        const newTransactionCount = Number(account.transactionCount || 0) + 1;\n        account = await upsertCreditAccount({\n            customerName: customerName,\n            balance: newBalance,\n            transactionCount: newTransactionCount,\n            lastTransactionDate: new Date(),\n            phone: account.phone,\n            email: account.email,\n            address: account.address,\n            notes: account.notes,\n            isActive: account.isActive\n        });\n    }\n    return account;\n}\nasync function payToCreditAccount(customerName, paymentAmount) {\n    const db = await connect();\n    const account = await getCreditAccountByName(customerName);\n    if (!account) {\n        throw new Error(\"Credit account not found\");\n    }\n    const currentBalance = Number(account.balance || 0);\n    const payment = Number(paymentAmount);\n    if (payment > currentBalance) {\n        throw new Error(\"Payment amount exceeds account balance\");\n    }\n    const newBalance = currentBalance - payment;\n    const updatedAccount = await upsertCreditAccount({\n        customerName: customerName,\n        balance: newBalance,\n        transactionCount: account.transactionCount,\n        lastTransactionDate: new Date(),\n        phone: account.phone,\n        email: account.email,\n        address: account.address,\n        notes: account.notes,\n        isActive: account.isActive\n    });\n    return {\n        ...updatedAccount,\n        paymentAmount: payment,\n        previousBalance: currentBalance,\n        newBalance: newBalance\n    };\n}\nasync function deleteCreditAccount(id) {\n    const db = await connect();\n    const { ObjectId } = __webpack_require__(/*! mongodb */ \"mongodb\");\n    try {\n        const objectId = new ObjectId(id);\n        const result = await db.collection(\"creditAccounts\").deleteOne({\n            _id: objectId\n        });\n        return result.deletedCount > 0;\n    } catch (error) {\n        console.error(\"Error deleting credit account:\", error);\n        return false;\n    }\n}\nasync function searchCreditAccounts(searchTerm, includeInactive = false) {\n    const db = await connect();\n    const query = {\n        customerName: {\n            $regex: searchTerm,\n            $options: \"i\"\n        }\n    };\n    if (!includeInactive) {\n        query.isActive = {\n            $ne: false\n        };\n    }\n    const cursor = db.collection(\"creditAccounts\").find(query).sort({\n        balance: -1,\n        lastTransactionDate: -1\n    });\n    const accounts = await cursor.toArray();\n    return accounts.map((account)=>({\n            ...account,\n            id: account._id.toString(),\n            createdAt: account.createdAt instanceof Date ? account.createdAt.toISOString() : account.createdAt,\n            updatedAt: account.updatedAt instanceof Date ? account.updatedAt.toISOString() : account.updatedAt,\n            lastTransactionDate: account.lastTransactionDate instanceof Date ? account.lastTransactionDate.toISOString() : account.lastTransactionDate\n        }));\n}\n// Till Count Management Functions\nasync function getCurrentTill() {\n    try {\n        const db = await connect();\n        const tillCollection = db.collection(\"tillCounts\");\n        // Find the most recent open till (no endTime)\n        const currentTill = await tillCollection.findOne({\n            endTime: null\n        }, {\n            sort: {\n                startTime: -1\n            }\n        });\n        return currentTill;\n    } catch (error) {\n        console.error(\"Error getting current till:\", error);\n        throw error;\n    }\n}\nasync function getTillHistory(limit = 20) {\n    try {\n        const db = await connect();\n        const tillCollection = db.collection(\"tillCounts\");\n        const history = await tillCollection.find({}).sort({\n            startTime: -1\n        }).limit(limit).toArray();\n        return history;\n    } catch (error) {\n        console.error(\"Error getting till history:\", error);\n        throw error;\n    }\n}\nasync function startTill(tillData) {\n    try {\n        const db = await connect();\n        const tillCollection = db.collection(\"tillCounts\");\n        // Generate a simple ID\n        const generateId = ()=>Date.now().toString() + Math.random().toString(36).substr(2, 9);\n        const till = {\n            id: generateId(),\n            startAmount: tillData.startAmount,\n            startUser: tillData.startUser,\n            startTime: tillData.startTime,\n            startDenominations: tillData.startDenominations || {},\n            endAmount: null,\n            endUser: null,\n            endTime: null,\n            endDenominations: null,\n            createdAt: new Date().toISOString()\n        };\n        await tillCollection.insertOne(till);\n        return till;\n    } catch (error) {\n        console.error(\"Error starting till:\", error);\n        throw error;\n    }\n}\nasync function endTill(tillId, endData) {\n    try {\n        const db = await connect();\n        const tillCollection = db.collection(\"tillCounts\");\n        const updateResult = await tillCollection.updateOne({\n            id: tillId\n        }, {\n            $set: {\n                endAmount: endData.endAmount,\n                endUser: endData.endUser,\n                endTime: endData.endTime,\n                endDenominations: endData.endDenominations || {},\n                updatedAt: new Date().toISOString()\n            }\n        });\n        if (updateResult.matchedCount === 0) {\n            throw new Error(\"Till not found\");\n        }\n        const updatedTill = await tillCollection.findOne({\n            id: tillId\n        });\n        return updatedTill;\n    } catch (error) {\n        console.error(\"Error ending till:\", error);\n        throw error;\n    }\n}\nmodule.exports = {\n    connect,\n    getAllInventory,\n    getInventoryById,\n    upsertInventoryItems,\n    deleteInventoryById,\n    getUsers,\n    getUserByUsername,\n    upsertUser,\n    replaceAllUsers,\n    deleteUserById,\n    saveTransaction,\n    getTransactions,\n    deleteTransaction,\n    getCategories,\n    saveCategory,\n    deleteCategory,\n    getCreditAccounts,\n    getCreditAccountByName,\n    upsertCreditAccount,\n    addToCreditAccount,\n    payToCreditAccount,\n    deleteCreditAccount,\n    searchCreditAccounts,\n    getCurrentTill,\n    getTillHistory,\n    startTill,\n    endTill\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cGFjazovL2NvbnZlbmllbmNlLXN0b3JlLWludmVudG9yeS8uL3NlcnZlci9tb25nby5qcz85NWU5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgTW9uZ29DbGllbnQgfSA9IHJlcXVpcmUoJ21vbmdvZGInKTtcclxuY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuTU9OR09fVVJJIHx8ICdtb25nb2RiOi8vbG9jYWxob3N0OjI3MDE3JztcclxuY29uc3QgZGJOYW1lID0gcHJvY2Vzcy5lbnYuTU9OR09fREIgfHwgJ2NvbnZlbmllbmNlX3N0b3JlJztcclxuXHJcbmxldCBfY2xpZW50ID0gbnVsbDtcclxubGV0IF9kYiA9IG51bGw7XHJcblxyXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0KCkge1xyXG4gIGlmIChfZGIpIHJldHVybiBfZGI7XHJcbiAgaWYgKCFfY2xpZW50KSB7XHJcbiAgICBfY2xpZW50ID0gbmV3IE1vbmdvQ2xpZW50KHVybCwgeyB1c2VVbmlmaWVkVG9wb2xvZ3k6IHRydWUgfSk7XHJcbiAgICBhd2FpdCBfY2xpZW50LmNvbm5lY3QoKTtcclxuICB9XHJcbiAgX2RiID0gX2NsaWVudC5kYihkYk5hbWUpO1xyXG4gIC8vIEVuc3VyZSBpbmRleGVzXHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IF9kYi5jb2xsZWN0aW9uKCdpbnZlbnRvcnknKS5jcmVhdGVJbmRleCh7IGlkOiAxIH0sIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgYXdhaXQgX2RiLmNvbGxlY3Rpb24oJ3VzZXJzJykuY3JlYXRlSW5kZXgoeyBpZDogMSB9LCB7IHVuaXF1ZTogdHJ1ZSwgc3BhcnNlOiB0cnVlIH0pO1xyXG4gICAgYXdhaXQgX2RiLmNvbGxlY3Rpb24oJ3VzZXJzJykuY3JlYXRlSW5kZXgoeyB1c2VybmFtZTogMSB9LCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBpZ25vcmUgaW5kZXggZXJyb3JzXHJcbiAgfVxyXG4gIHJldHVybiBfZGI7XHJcbn1cclxuXHJcbi8vIEludmVudG9yeSBoZWxwZXJzXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEFsbEludmVudG9yeSgpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICByZXR1cm4gZGIuY29sbGVjdGlvbignaW52ZW50b3J5JykuZmluZCh7fSkuc29ydCh7IG5hbWU6IDEgfSkudG9BcnJheSgpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRJbnZlbnRvcnlCeUlkKGlkKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3QgbiA9IE51bWJlcihpZCk7XHJcbiAgcmV0dXJuIGRiLmNvbGxlY3Rpb24oJ2ludmVudG9yeScpLmZpbmRPbmUoeyBpZDogbiB9KTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gdXBzZXJ0SW52ZW50b3J5SXRlbXMoaXRlbXMpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSBpdGVtcyA9IFtpdGVtc107XHJcbiAgY29uc29sZS5sb2coJ3Vwc2VydEludmVudG9yeUl0ZW1zIGNhbGxlZCB3aXRoOicsIGl0ZW1zLmxlbmd0aCwgJ2l0ZW1zJyk7XHJcbiAgXHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3Qgb3BzID0gaXRlbXMubWFwKChpdCwgaW5kZXgpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIGl0ZW0gJHtpbmRleH0gZm9yIHVwc2VydDpgLCBKU09OLnN0cmluZ2lmeShpdCwgbnVsbCwgMikpO1xyXG4gICAgXHJcbiAgICAvLyBWYWxpZGF0ZSBhbmQgY29udmVydCBJRFxyXG4gICAgbGV0IGl0ZW1JZCA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChpdC5pZCAhPT0gdW5kZWZpbmVkICYmIGl0LmlkICE9PSBudWxsKSB7XHJcbiAgICAgIGl0ZW1JZCA9IE51bWJlcihpdC5pZCk7XHJcbiAgICAgIGlmIChpc05hTihpdGVtSWQpKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBJRCBmb3IgaXRlbSAke2luZGV4fTpgLCBpdC5pZCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIElEOiAke2l0LmlkfWApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKGBJdGVtICR7aW5kZXh9IGhhcyB2YWxpZCBudW1lcmljIElEOmAsIGl0ZW1JZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZyhgSXRlbSAke2luZGV4fSBoYXMgbm8gSUQsIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWRgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3Qgb2JqID0ge1xyXG4gICAgICBpZDogaXRlbUlkLFxyXG4gICAgICBuYW1lOiBpdC5uYW1lIHx8ICcnLFxyXG4gICAgICBjYXRlZ29yeTogaXQuY2F0ZWdvcnkgfHwgJycsXHJcbiAgICAgIHByaWNlOiBOdW1iZXIoaXQucHJpY2UgfHwgMCksXHJcbiAgICAgIHN0b2NrOiBOdW1iZXIoaXQuc3RvY2sgfHwgMCksXHJcbiAgICAgIGxvd1N0b2NrVGhyZXNob2xkOiBOdW1iZXIoaXQubG93U3RvY2tUaHJlc2hvbGQgfHwgMCksXHJcbiAgICAgIHRheGFibGU6ICEhaXQudGF4YWJsZSxcclxuICAgICAgYmFyY29kZTogaXQuYmFyY29kZSB8fCAoaXRlbUlkID8gaXRlbUlkLnRvU3RyaW5nKCkgOiBudWxsKSwgIC8vIERlZmF1bHQgdG8gcHJvZHVjdCBJRCBhcyBiYXJjb2RlXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLyBBZGQgYmFyY29kZTIgaWYgcHJvdmlkZWRcclxuICAgIGlmIChpdC5iYXJjb2RlMikge1xyXG4gICAgICBvYmouYmFyY29kZTIgPSBpdC5iYXJjb2RlMjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gT25seSBhZGQgcHJvZHVjdElkIGlmIGl0J3MgcHJvdmlkZWQsIHRvIGF2b2lkIG51bGwgY29uc3RyYWludCBpc3N1ZXNcclxuICAgIGlmIChpdC5wcm9kdWN0SWQpIHtcclxuICAgICAgb2JqLnByb2R1Y3RJZCA9IGl0LnByb2R1Y3RJZDtcclxuICAgIH0gZWxzZSBpZiAoaXRlbUlkKSB7XHJcbiAgICAgIG9iai5wcm9kdWN0SWQgPSBpdGVtSWQudG9TdHJpbmcoKTsgLy8gVXNlIElEIGFzIHByb2R1Y3RJZCBmb3IgbmV3IGl0ZW1zXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgaWYgKCFvYmoubmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEl0ZW0gbmFtZSBpcyByZXF1aXJlZCBmb3IgaXRlbSAke2luZGV4fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyByZW1vdmUgdW5kZWZpbmVkIGlkIHRvIGxldCB1cHNlcnQgdXNlIHByb3ZpZGVkIGlkIG9yIGNyZWF0ZSBvbmVcclxuICAgIGlmIChvYmouaWQgPT09IHVuZGVmaW5lZCkgZGVsZXRlIG9iai5pZDtcclxuICAgIFxyXG4gICAgY29uc3QgZmlsdGVyID0gb2JqLmlkICE9PSB1bmRlZmluZWQgPyB7IGlkOiBvYmouaWQgfSA6IHsgbmFtZTogb2JqLm5hbWUgfTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYD09PSBNT05HT0RCIFVQU0VSVCBPUEVSQVRJT04gJHtpbmRleH0gPT09YCk7XHJcbiAgICBjb25zb2xlLmxvZygnRmlsdGVyOicsIEpTT04uc3RyaW5naWZ5KGZpbHRlciwgbnVsbCwgMikpO1xyXG4gICAgY29uc29sZS5sb2coJ1VwZGF0ZSBkb2N1bWVudDonLCBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpKTtcclxuICAgIGNvbnNvbGUubG9nKGBJdGVtICR7aW5kZXh9IGZpbHRlcjpgLCBmaWx0ZXIpO1xyXG4gICAgY29uc29sZS5sb2coYEl0ZW0gJHtpbmRleH0gb2JqZWN0OmAsIG9iaik7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVwZGF0ZU9uZToge1xyXG4gICAgICAgIGZpbHRlcixcclxuICAgICAgICB1cGRhdGU6IHsgJHNldDogb2JqIH0sXHJcbiAgICAgICAgdXBzZXJ0OiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9KTtcclxuICBcclxuICBpZiAob3BzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgY29uc29sZS5sb2coJ05vIG9wZXJhdGlvbnMgdG8gcGVyZm9ybScpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBcclxuICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIGJ1bGtXcml0ZSB3aXRoJywgb3BzLmxlbmd0aCwgJ29wZXJhdGlvbnMnKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGIuY29sbGVjdGlvbignaW52ZW50b3J5JykuYnVsa1dyaXRlKG9wcyk7XHJcbiAgICBjb25zb2xlLmxvZygnQnVsa1dyaXRlIHJlc3VsdDonLCByZXN1bHQpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdCdWxrV3JpdGUgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgXHJcbiAgICAvLyBJZiBpdCdzIGEgZHVwbGljYXRlIGtleSBlcnJvciBvbiBwcm9kdWN0SWQsIHRyeSB0byBoYW5kbGUgaXQgZ3JhY2VmdWxseVxyXG4gICAgaWYgKGVycm9yLmNvZGUgPT09IDExMDAwICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3Byb2R1Y3RJZCcpKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdEZXRlY3RlZCBwcm9kdWN0SWQgZHVwbGljYXRlIGtleSBlcnJvciwgYXR0ZW1wdGluZyBpbmRpdmlkdWFsIHVwc2VydHMuLi4nKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRyeSBlYWNoIGl0ZW0gaW5kaXZpZHVhbGx5IHdpdGggdW5pcXVlIHByb2R1Y3RJZCBnZW5lcmF0aW9uXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW1XaXRoVW5pcXVlUHJvZHVjdElkID0ge1xyXG4gICAgICAgICAgICAuLi5pdGVtLFxyXG4gICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdElkIHx8IGAke2l0ZW0uaWQgfHwgRGF0ZS5ub3coKX0tJHtpfWBcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGl0ZW0uaWQgPyB7IGlkOiBpdGVtLmlkIH0gOiB7IG5hbWU6IGl0ZW0ubmFtZSB9O1xyXG4gICAgICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignaW52ZW50b3J5JykudXBkYXRlT25lKFxyXG4gICAgICAgICAgICBmaWx0ZXIsXHJcbiAgICAgICAgICAgIHsgJHNldDogaXRlbVdpdGhVbmlxdWVQcm9kdWN0SWQgfSxcclxuICAgICAgICAgICAgeyB1cHNlcnQ6IHRydWUgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgdXBzZXJ0ZWQgaXRlbSAke2l9IHdpdGggdW5pcXVlIHByb2R1Y3RJZGApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGluZGl2aWR1YWxFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHVwc2VydCBpbmRpdmlkdWFsIGl0ZW0gJHtpfTpgLCBpbmRpdmlkdWFsRXJyb3IpO1xyXG4gICAgICAgICAgdGhyb3cgaW5kaXZpZHVhbEVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmxvZygnQWxsIGl0ZW1zIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkgdmlhIGluZGl2aWR1YWwgdXBzZXJ0cycpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlSW52ZW50b3J5QnlJZChpZCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IG4gPSBOdW1iZXIoaWQpO1xyXG4gIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2ludmVudG9yeScpLmRlbGV0ZU9uZSh7IGlkOiBuIH0pO1xyXG59XHJcblxyXG4vLyBVc2VycyBoZWxwZXJzXHJcbmFzeW5jIGZ1bmN0aW9uIGdldFVzZXJzKCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IHVzZXJzID0gYXdhaXQgZGIuY29sbGVjdGlvbigndXNlcnMnKS5maW5kKHt9KS5zb3J0KHsgaWQ6IDEgfSkudG9BcnJheSgpO1xyXG4gIFxyXG4gIC8vIEF1dG8tY3JlYXRlIGRlZmF1bHQgdXNlcnMgaWYgbm8gdXNlcnMgZXhpc3RcclxuICBpZiAodXNlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICBjb25zb2xlLmxvZygnTm8gdXNlcnMgZm91bmQuIENyZWF0aW5nIGRlZmF1bHQgYWRtaW4gYW5kIGNhc2hpZXIgdXNlcnMuLi4nKTtcclxuICAgIFxyXG4gICAgY29uc3QgZGVmYXVsdFVzZXJzID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6ICdhZG1pbicsXHJcbiAgICAgICAgcHdkOiAnYWRtaW4xMjMnLFxyXG4gICAgICAgIHJvbGU6ICdBZG1pbicsXHJcbiAgICAgICAgZW1haWw6ICdhZG1pbkBwb3MubG9jYWwnLFxyXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBwZXJtaXNzaW9uc19qc29uOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBpbnZlbnRvcnk6IHRydWUsXHJcbiAgICAgICAgICB1c2VyczogdHJ1ZSxcclxuICAgICAgICAgIHJlcG9ydHM6IHRydWUsXHJcbiAgICAgICAgICBwb3M6IHRydWUsXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRydWUsXHJcbiAgICAgICAgICBtYW5hZ2VVc2VyczogdHJ1ZSxcclxuICAgICAgICAgIG1hbmFnZUludmVudG9yeTogdHJ1ZSxcclxuICAgICAgICAgIG1hbmFnZVJlcG9ydHM6IHRydWUsXHJcbiAgICAgICAgICBtYW5hZ2VQT1M6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6ICdjYXNoaWVyJyxcclxuICAgICAgICBwd2Q6ICdjYXNoaWVyMScsXHJcbiAgICAgICAgcm9sZTogJ0Nhc2hpZXInLFxyXG4gICAgICAgIGVtYWlsOiAnY2FzaGllckBwb3MubG9jYWwnLFxyXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcclxuICAgICAgICBwZXJtaXNzaW9uc19qc29uOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBpbnZlbnRvcnk6IGZhbHNlLFxyXG4gICAgICAgICAgdXNlcnM6IGZhbHNlLFxyXG4gICAgICAgICAgcmVwb3J0czogZmFsc2UsXHJcbiAgICAgICAgICBwb3M6IHRydWUsXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbnM6IGZhbHNlLFxyXG4gICAgICAgICAgbWFuYWdlVXNlcnM6IGZhbHNlLFxyXG4gICAgICAgICAgbWFuYWdlSW52ZW50b3J5OiBmYWxzZSxcclxuICAgICAgICAgIG1hbmFnZVJlcG9ydHM6IGZhbHNlLFxyXG4gICAgICAgICAgbWFuYWdlUE9TOiB0cnVlXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbigndXNlcnMnKS5pbnNlcnRNYW55KGRlZmF1bHRVc2Vycyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgRGVmYXVsdCB1c2VycyBjcmVhdGVkOicpO1xyXG4gICAgICBjb25zb2xlLmxvZygnICAgLSBBZG1pbjogdXNlcm5hbWU9YWRtaW4sIHBhc3N3b3JkPWFkbWluMTIzJyk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCcgICAtIENhc2hpZXI6IHVzZXJuYW1lPWNhc2hpZXIsIHBhc3N3b3JkPWNhc2hpZXIxJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGRlZmF1bHQgdXNlcnM6JywgZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBuZXdVc2VycyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3VzZXJzJykuZmluZCh7fSkuc29ydCh7IGlkOiAxIH0pLnRvQXJyYXkoKTtcclxuICAgIHJldHVybiBuZXdVc2Vycy5tYXAodXNlciA9PiAoe1xyXG4gICAgICAuLi51c2VyLFxyXG4gICAgICB1c2VybmFtZTogdXNlci5pZCB8fCB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICBwYXNzd29yZDogdXNlci5wd2QgfHwgdXNlci5wYXNzd29yZCB8fCAnJ1xyXG4gICAgfSkpO1xyXG4gIH1cclxuICBcclxuICAvLyBNYXAgZGF0YWJhc2UgZmllbGRzIHRvIGZyb250ZW5kIGV4cGVjdGVkIGZpZWxkc1xyXG4gIHJldHVybiB1c2Vycy5tYXAodXNlciA9PiAoe1xyXG4gICAgLi4udXNlcixcclxuICAgIHVzZXJuYW1lOiB1c2VyLmlkLCAvLyBNYXAgaWQgdG8gdXNlcm5hbWUgZm9yIGZyb250ZW5kXHJcbiAgICBwYXNzd29yZDogdXNlci5wd2QgfHwgdXNlci5wYXNzd29yZCAvLyBNYXAgcHdkIHRvIHBhc3N3b3JkIGZvciBmcm9udGVuZFxyXG4gIH0pKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckJ5VXNlcm5hbWUodXNlcm5hbWUpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICAvLyBUcnkgdG8gZmluZCB1c2VyIGJ5IGlkIGZpcnN0LCB0aGVuIGJ5IHVzZXJuYW1lIGZpZWxkIGlmIGl0IGV4aXN0c1xyXG4gIGxldCB1c2VyID0gYXdhaXQgZGIuY29sbGVjdGlvbigndXNlcnMnKS5maW5kT25lKHsgaWQ6IHVzZXJuYW1lIH0pO1xyXG4gIGlmICghdXNlcikge1xyXG4gICAgdXNlciA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3VzZXJzJykuZmluZE9uZSh7IHVzZXJuYW1lOiB1c2VybmFtZSB9KTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKHVzZXIpIHtcclxuICAgIC8vIE1hcCBkYXRhYmFzZSBmaWVsZHMgdG8gZnJvbnRlbmQgZXhwZWN0ZWQgZmllbGRzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi51c2VyLFxyXG4gICAgICB1c2VybmFtZTogdXNlci5pZCB8fCB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICBwYXNzd29yZDogdXNlci5wd2QgfHwgdXNlci5wYXNzd29yZCB8fCAnJ1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHVwc2VydFVzZXIoYm9keSkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IGlkID0gYm9keS5pZCB8fCBib2R5LnVzZXJuYW1lO1xyXG4gIGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3VzZXJzJykudXBkYXRlT25lKFxyXG4gICAgeyBpZCB9LFxyXG4gICAge1xyXG4gICAgICAkc2V0OiB7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZW1haWw6IGJvZHkuZW1haWwgfHwgJycsXHJcbiAgICAgICAgcHdkOiBib2R5LnBhc3N3b3JkIHx8IGJvZHkucHdkIHx8ICcnLCAvLyBTdG9yZSBhcyBwd2QgaW4gZGF0YWJhc2VcclxuICAgICAgICByb2xlOiBib2R5LnJvbGUgfHwgJ3VzZXInLFxyXG4gICAgICAgIGFjdGl2ZTogYm9keS5hY3RpdmUgIT09IGZhbHNlLFxyXG4gICAgICAgIHBlcm1pc3Npb25zX2pzb246IEpTT04uc3RyaW5naWZ5KGJvZHkucGVybWlzc2lvbnMgfHwge30pLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHsgdXBzZXJ0OiB0cnVlIH1cclxuICApO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiByZXBsYWNlQWxsVXNlcnModXNlcnMpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICBcclxuICAvLyBDbGVhciBleGlzdGluZyB1c2VycyBhbmQgaW5zZXJ0IG5ldyBvbmVzXHJcbiAgYXdhaXQgZGIuY29sbGVjdGlvbigndXNlcnMnKS5kZWxldGVNYW55KHt9KTtcclxuICBcclxuICBpZiAodXNlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgY29uc3QgZm9ybWF0dGVkVXNlcnMgPSB1c2Vycy5tYXAodXNlciA9PiAoe1xyXG4gICAgICBpZDogdXNlci5pZCB8fCB1c2VyLnVzZXJuYW1lLFxyXG4gICAgICBlbWFpbDogdXNlci5lbWFpbCB8fCAnJyxcclxuICAgICAgcHdkOiB1c2VyLnBhc3N3b3JkIHx8IHVzZXIucHdkIHx8ICcnLCAvLyBTdG9yZSBhcyBwd2QgaW4gZGF0YWJhc2VcclxuICAgICAgcm9sZTogdXNlci5yb2xlIHx8ICd1c2VyJyxcclxuICAgICAgYWN0aXZlOiB1c2VyLmFjdGl2ZSAhPT0gZmFsc2UsXHJcbiAgICAgIHBlcm1pc3Npb25zX2pzb246IEpTT04uc3RyaW5naWZ5KHVzZXIucGVybWlzc2lvbnMgfHwge30pLFxyXG4gICAgfSkpO1xyXG4gICAgXHJcbiAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCd1c2VycycpLmluc2VydE1hbnkoZm9ybWF0dGVkVXNlcnMpO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlVXNlckJ5SWQoaWQpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICBcclxuICAvLyBQcmV2ZW50IGRlbGV0aW9uIG9mIGFkbWluIHVzZXJzIChzdXBlciByb2xlIHByb3RlY3Rpb24pXHJcbiAgY29uc3QgdXNlciA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3VzZXJzJykuZmluZE9uZSh7IGlkOiBpZCB9KTtcclxuICBpZiAodXNlciAmJiAodXNlci5yb2xlID09PSAnYWRtaW4nIHx8IHVzZXIucm9sZSA9PT0gJ0FkbWluJyB8fCB1c2VyLmlkID09PSAnYWRtaW4nKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZG1pbiB1c2VycyBjYW5ub3QgYmUgZGVsZXRlZCAtIHRoaXMgaXMgYSBwcm90ZWN0ZWQgc3VwZXIgcm9sZScpO1xyXG4gIH1cclxuICBcclxuICBhd2FpdCBkYi5jb2xsZWN0aW9uKCd1c2VycycpLmRlbGV0ZU9uZSh7IGlkOiBpZCB9KTtcclxufVxyXG5cclxuLy8gVHJhbnNhY3Rpb25zIGhlbHBlcnNcclxuYXN5bmMgZnVuY3Rpb24gc2F2ZVRyYW5zYWN0aW9uKHR4T2JqKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYW5zYWN0aW9uIHR5cGUgYmFzZWQgb24gcGF5bWVudCBicmVha2Rvd25cclxuICBjb25zdCBwYXltZW50QnJlYWtkb3duID0gdHhPYmoucGF5bWVudEJyZWFrZG93biB8fCB0eE9iai5wYXltZW50IHx8IFtdO1xyXG4gIGxldCB0cmFuc2FjdGlvblR5cGUgPSAnbWl4ZWQnOyAvLyBkZWZhdWx0XHJcbiAgbGV0IGNhc2hBbW91bnQgPSAwO1xyXG4gIGxldCBjYXJkQW1vdW50ID0gMDtcclxuICBsZXQgY3JlZGl0QW1vdW50ID0gMDtcclxuICBcclxuICAvLyBDYWxjdWxhdGUgcGF5bWVudCBhbW91bnRzIGJ5IG1ldGhvZFxyXG4gIGxldCBoYXNMb3R0byA9IGZhbHNlO1xyXG4gIHBheW1lbnRCcmVha2Rvd24uZm9yRWFjaChwYXltZW50ID0+IHtcclxuICAgIGNvbnN0IGFtb3VudCA9IE51bWJlcihwYXltZW50LmFtb3VudCB8fCAwKTtcclxuICAgIHN3aXRjaCAocGF5bWVudC5tZXRob2Q/LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgY2FzZSAnY2FzaCc6XHJcbiAgICAgICAgY2FzaEFtb3VudCArPSBhbW91bnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2NhcmQnOlxyXG4gICAgICAgIGNhcmRBbW91bnQgKz0gYW1vdW50O1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjcmVkaXQnOlxyXG4gICAgICAgIGNyZWRpdEFtb3VudCArPSBhbW91bnQ7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2xvdHRvJzpcclxuICAgICAgICBoYXNMb3R0byA9IHRydWU7XHJcbiAgICAgICAgLy8gTG90dG8gd2lubmluZ3MgZG9uJ3QgY291bnQgYXMgcGF5bWVudCwgdGhleSByZWR1Y2UgdG90YWwgb3dlZFxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIERldGVybWluZSBwcmltYXJ5IHRyYW5zYWN0aW9uIHR5cGVcclxuICBpZiAoaGFzTG90dG8gJiYgY2FzaEFtb3VudCA8IDAgJiYgY2FyZEFtb3VudCA9PT0gMCAmJiBjcmVkaXRBbW91bnQgPT09IDApIHtcclxuICAgIC8vIExvdHRvLW9ubHkgdHJhbnNhY3Rpb24gKGNhc2ggZ29pbmcgb3V0KVxyXG4gICAgdHJhbnNhY3Rpb25UeXBlID0gJ2xvdHRvJztcclxuICB9IGVsc2UgaWYgKGNyZWRpdEFtb3VudCA+IDApIHtcclxuICAgIGlmIChjYXNoQW1vdW50ID4gMCB8fCBjYXJkQW1vdW50ID4gMCkge1xyXG4gICAgICB0cmFuc2FjdGlvblR5cGUgPSAncGFydGlhbF9jcmVkaXQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJhbnNhY3Rpb25UeXBlID0gJ2NyZWRpdCc7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChjYXNoQW1vdW50ID4gMCAmJiBjYXJkQW1vdW50ID4gMCkge1xyXG4gICAgdHJhbnNhY3Rpb25UeXBlID0gJ21peGVkJztcclxuICB9IGVsc2UgaWYgKGNhc2hBbW91bnQgPiAwKSB7XHJcbiAgICB0cmFuc2FjdGlvblR5cGUgPSAnY2FzaCc7XHJcbiAgfSBlbHNlIGlmIChjYXJkQW1vdW50ID4gMCkge1xyXG4gICAgdHJhbnNhY3Rpb25UeXBlID0gJ2NhcmQnO1xyXG4gIH0gZWxzZSBpZiAoaGFzTG90dG8pIHtcclxuICAgIC8vIExvdHRvIHdpdGggb3RoZXIgcGF5bWVudHNcclxuICAgIHRyYW5zYWN0aW9uVHlwZSA9ICdsb3R0b19taXhlZCc7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIG5vcm1hbGl6ZSB0aW1lc3RhbXBcclxuICBjb25zdCBkb2MgPSB7XHJcbiAgICBsZWdhY3lfaWQ6IHR4T2JqLmlkIHx8IG51bGwsXHJcbiAgICB0aW1lc3RhbXA6IHR4T2JqLnRpbWVzdGFtcCA/IG5ldyBEYXRlKHR4T2JqLnRpbWVzdGFtcCkgOiBuZXcgRGF0ZSgpLFxyXG4gICAgc3VidG90YWw6IE51bWJlcih0eE9iai5zdWJ0b3RhbCB8fCAwKSxcclxuICAgIHRheGFibGVBbW91bnQ6IE51bWJlcih0eE9iai50YXhhYmxlQW1vdW50IHx8IDApLFxyXG4gICAgbm9uVGF4YWJsZUFtb3VudDogTnVtYmVyKHR4T2JqLm5vblRheGFibGVBbW91bnQgfHwgMCksXHJcbiAgICB0YXg6IE51bWJlcih0eE9iai50YXggfHwgMCksXHJcbiAgICB0b3RhbDogTnVtYmVyKHR4T2JqLnRvdGFsIHx8IDApLFxyXG4gICAgY2FzaGJhY2s6IE51bWJlcih0eE9iai5jYXNoYmFjayB8fCAwKSxcclxuICAgIHBheW1lbnRCcmVha2Rvd246IHBheW1lbnRCcmVha2Rvd24sXHJcbiAgICBjaGFuZ2U6IE51bWJlcih0eE9iai5jaGFuZ2UgfHwgMCksXHJcbiAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uVHlwZSwgLy8gTmV3IGZpZWxkOiAnY2FzaCcsICdjYXJkJywgJ21peGVkJywgJ2NyZWRpdCcsICdwYXJ0aWFsX2NyZWRpdCdcclxuICAgIGNhc2hBbW91bnQ6IGNhc2hBbW91bnQsICAgICAgICAgICAvLyBOZXcgZmllbGQ6IFRvdGFsIGNhc2ggYW1vdW50XHJcbiAgICBjYXJkQW1vdW50OiBjYXJkQW1vdW50LCAgICAgICAgICAgLy8gTmV3IGZpZWxkOiBUb3RhbCBjYXJkIGFtb3VudCAgXHJcbiAgICBjcmVkaXRBbW91bnQ6IGNyZWRpdEFtb3VudCwgICAgICAgLy8gTmV3IGZpZWxkOiBUb3RhbCBjcmVkaXQgYW1vdW50XHJcbiAgICBpdGVtczogQXJyYXkuaXNBcnJheSh0eE9iai5pdGVtcykgPyB0eE9iai5pdGVtcy5tYXAoKGl0KSA9PiAoe1xyXG4gICAgICBwcm9kdWN0X2lkOiBpdC5pZCB8fCBudWxsLFxyXG4gICAgICBuYW1lOiBpdC5uYW1lIHx8ICcnLFxyXG4gICAgICBxdWFudGl0eTogTnVtYmVyKGl0LnF1YW50aXR5IHx8IDApLFxyXG4gICAgICBwcmljZTogTnVtYmVyKGl0LnByaWNlIHx8IDApLFxyXG4gICAgICBhcHBseVRheDogISFpdC5hcHBseVRheCxcclxuICAgIH0pKSA6IFtdLFxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3RyYW5zYWN0aW9ucycpLmluc2VydE9uZShkb2MpO1xyXG4gIGNvbnN0IGluc2VydGVkSWQgPSByZXMuaW5zZXJ0ZWRJZDtcclxuXHJcbiAgLy8gRGVkdWN0IHN0b2NrIGZvciBlYWNoIGl0ZW0gKGJlc3QtZWZmb3J0KVxyXG4gIGZvciAoY29uc3QgaXQgb2YgZG9jLml0ZW1zKSB7XHJcbiAgICBpZiAoIWl0LnByb2R1Y3RfaWQpIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgY3VyID0gYXdhaXQgZGIuY29sbGVjdGlvbignaW52ZW50b3J5JykuZmluZE9uZSh7IGlkOiBOdW1iZXIoaXQucHJvZHVjdF9pZCkgfSk7XHJcbiAgICBpZiAoY3VyKSB7XHJcbiAgICAgIGNvbnN0IG5ld1N0b2NrID0gKGN1ci5zdG9jayB8fCAwKSAtIChpdC5xdWFudGl0eSB8fCAwKTtcclxuICAgICAgYXdhaXQgZGIuY29sbGVjdGlvbignaW52ZW50b3J5JykudXBkYXRlT25lKHsgaWQ6IE51bWJlcihpdC5wcm9kdWN0X2lkKSB9LCB7ICRzZXQ6IHsgc3RvY2s6IG5ld1N0b2NrIH0gfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5zZXJ0ZWRJZDtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zKGxpbWl0ID0gMTAwKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3QgY3Vyc29yID0gZGIuY29sbGVjdGlvbigndHJhbnNhY3Rpb25zJykuZmluZCh7fSkuc29ydCh7IF9pZDogLTEgfSkubGltaXQoTnVtYmVyKGxpbWl0KSk7XHJcbiAgY29uc3Qgcm93cyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XHJcbiAgcmV0dXJuIHJvd3MubWFwKChyKSA9PiAoe1xyXG4gICAgLi4ucixcclxuICAgIGlkOiByLl9pZC50b1N0cmluZygpLCAvLyBDb252ZXJ0IE1vbmdvREIgT2JqZWN0SWQgdG8gc3RyaW5nIGZvciBmcm9udGVuZFxyXG4gICAgdGltZXN0YW1wOiByLnRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUgPyByLnRpbWVzdGFtcC50b0lTT1N0cmluZygpIDogci50aW1lc3RhbXAsXHJcbiAgfSkpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVUcmFuc2FjdGlvbihpZCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IHsgT2JqZWN0SWQgfSA9IHJlcXVpcmUoJ21vbmdvZGInKTtcclxuICBcclxuICB0cnkge1xyXG4gICAgLy8gQ29udmVydCBzdHJpbmcgSUQgdG8gT2JqZWN0SWQgZm9yIE1vbmdvREJcclxuICAgIGNvbnN0IG9iamVjdElkID0gbmV3IE9iamVjdElkKGlkKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ3RyYW5zYWN0aW9ucycpLmRlbGV0ZU9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmRlbGV0ZWRDb3VudCA+IDA7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHRyYW5zYWN0aW9uOicsIGVycm9yKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIENhdGVnb3JpZXMgaGVscGVyc1xyXG5hc3luYyBmdW5jdGlvbiBnZXRDYXRlZ29yaWVzKCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IGNhdGVnb3JpZXMgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYXRlZ29yaWVzJykuZmluZCh7fSkuc29ydCh7IG5hbWU6IDEgfSkudG9BcnJheSgpO1xyXG4gIFxyXG4gIC8vIElmIG5vIGNhdGVnb3JpZXMgZXhpc3QsIGNyZWF0ZSBkZWZhdWx0IG9uZXNcclxuICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcclxuICAgIGNvbnN0IGRlZmF1bHRDYXRlZ29yaWVzID0gW1xyXG4gICAgICB7IGlkOiAxLCBuYW1lOiBcIkJldmVyYWdlc1wiLCBkZXNjcmlwdGlvbjogXCJTb2Z0IGRyaW5rcywgZW5lcmd5IGRyaW5rcywgd2F0ZXIsIGFuZCBvdGhlciBiZXZlcmFnZXNcIiB9LFxyXG4gICAgICB7IGlkOiAyLCBuYW1lOiBcIlNuYWNrc1wiLCBkZXNjcmlwdGlvbjogXCJDaGlwcywgY3JhY2tlcnMsIG51dHMsIGFuZCBvdGhlciBzbmFjayBmb29kc1wiIH0sXHJcbiAgICAgIHsgaWQ6IDMsIG5hbWU6IFwiQmFrZXJ5XCIsIGRlc2NyaXB0aW9uOiBcIkJyZWFkLCBwYXN0cmllcywgYW5kIGJha2VkIGdvb2RzXCIgfSxcclxuICAgICAgeyBpZDogNCwgbmFtZTogXCJUb2JhY2NvXCIsIGRlc2NyaXB0aW9uOiBcIkNpZ2FyZXR0ZXMgYW5kIHRvYmFjY28gcHJvZHVjdHNcIiB9LFxyXG4gICAgICB7IGlkOiA1LCBuYW1lOiBcIkRhaXJ5XCIsIGRlc2NyaXB0aW9uOiBcIk1pbGssIGNoZWVzZSwgeW9ndXJ0LCBhbmQgZGFpcnkgcHJvZHVjdHNcIiB9LFxyXG4gICAgICB7IGlkOiA2LCBuYW1lOiBcIkZyb3plbiBGb29kc1wiLCBkZXNjcmlwdGlvbjogXCJJY2UgY3JlYW0sIGZyb3plbiBtZWFscywgYW5kIGZyb3plbiBpdGVtc1wiIH0sXHJcbiAgICAgIHsgaWQ6IDcsIG5hbWU6IFwiUGVyc29uYWwgQ2FyZVwiLCBkZXNjcmlwdGlvbjogXCJUb2lsZXRyaWVzLCBoeWdpZW5lLCBhbmQgcGVyc29uYWwgY2FyZSBpdGVtc1wiIH0sXHJcbiAgICAgIHsgaWQ6IDgsIG5hbWU6IFwiSG91c2Vob2xkXCIsIGRlc2NyaXB0aW9uOiBcIkNsZWFuaW5nIHN1cHBsaWVzLCBwYXBlciBwcm9kdWN0cywgYW5kIGhvdXNlaG9sZCBpdGVtc1wiIH0sXHJcbiAgICAgIHsgaWQ6IDksIG5hbWU6IFwiRnJlc2ggUHJvZHVjZVwiLCBkZXNjcmlwdGlvbjogXCJGcnVpdHMsIHZlZ2V0YWJsZXMsIGFuZCBmcmVzaCBwcm9kdWNlXCIgfSxcclxuICAgICAgeyBpZDogMTAsIG5hbWU6IFwiQ2FuZHlcIiwgZGVzY3JpcHRpb246IFwiQ2hvY29sYXRlcywgZ3VtcywgYW5kIHN3ZWV0IHRyZWF0c1wiIH0sXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYXRlZ29yaWVzJykuaW5zZXJ0TWFueShkZWZhdWx0Q2F0ZWdvcmllcyk7XHJcbiAgICByZXR1cm4gZGVmYXVsdENhdGVnb3JpZXM7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBjYXRlZ29yaWVzO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBzYXZlQ2F0ZWdvcnkoY2F0ZWdvcnkpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICBcclxuICBpZiAoY2F0ZWdvcnkuaWQpIHtcclxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyBjYXRlZ29yeVxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGIuY29sbGVjdGlvbignY2F0ZWdvcmllcycpLnVwZGF0ZU9uZShcclxuICAgICAgeyBpZDogTnVtYmVyKGNhdGVnb3J5LmlkKSB9LFxyXG4gICAgICB7IFxyXG4gICAgICAgICRzZXQ6IHtcclxuICAgICAgICAgIG5hbWU6IGNhdGVnb3J5Lm5hbWUsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogY2F0ZWdvcnkuZGVzY3JpcHRpb24gfHwgJycsXHJcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHsgdXBzZXJ0OiB0cnVlIH1cclxuICAgICk7XHJcbiAgICByZXR1cm4geyBpZDogY2F0ZWdvcnkuaWQsIC4uLmNhdGVnb3J5IH07XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIENyZWF0ZSBuZXcgY2F0ZWdvcnkgLSBmaW5kIG5leHQgYXZhaWxhYmxlIElEXHJcbiAgICBjb25zdCBsYXN0Q2F0ZWdvcnkgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjYXRlZ29yaWVzJykuZmluZE9uZSh7fSwgeyBzb3J0OiB7IGlkOiAtMSB9IH0pO1xyXG4gICAgY29uc3QgbmV4dElkID0gKGxhc3RDYXRlZ29yeT8uaWQgfHwgMCkgKyAxO1xyXG4gICAgXHJcbiAgICBjb25zdCBuZXdDYXRlZ29yeSA9IHtcclxuICAgICAgaWQ6IG5leHRJZCxcclxuICAgICAgbmFtZTogY2F0ZWdvcnkubmFtZSxcclxuICAgICAgZGVzY3JpcHRpb246IGNhdGVnb3J5LmRlc2NyaXB0aW9uIHx8ICcnLFxyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXdhaXQgZGIuY29sbGVjdGlvbignY2F0ZWdvcmllcycpLmluc2VydE9uZShuZXdDYXRlZ29yeSk7XHJcbiAgICByZXR1cm4gbmV3Q2F0ZWdvcnk7XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVDYXRlZ29yeShpZCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NhdGVnb3JpZXMnKS5kZWxldGVPbmUoeyBpZDogTnVtYmVyKGlkKSB9KTtcclxuICByZXR1cm4gcmVzdWx0LmRlbGV0ZWRDb3VudCA+IDA7XHJcbn1cclxuXHJcbi8vIENyZWRpdCBBY2NvdW50cyBoZWxwZXJzXHJcbmFzeW5jIGZ1bmN0aW9uIGdldENyZWRpdEFjY291bnRzKCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIGNvbnN0IGN1cnNvciA9IGRiLmNvbGxlY3Rpb24oJ2NyZWRpdEFjY291bnRzJykuZmluZCh7fSkuc29ydCh7IGxhc3RUcmFuc2FjdGlvbkRhdGU6IC0xIH0pO1xyXG4gIGNvbnN0IGFjY291bnRzID0gYXdhaXQgY3Vyc29yLnRvQXJyYXkoKTtcclxuICByZXR1cm4gYWNjb3VudHMubWFwKChhY2NvdW50KSA9PiAoe1xyXG4gICAgLi4uYWNjb3VudCxcclxuICAgIGlkOiBhY2NvdW50Ll9pZC50b1N0cmluZygpLFxyXG4gICAgY3JlYXRlZEF0OiBhY2NvdW50LmNyZWF0ZWRBdCBpbnN0YW5jZW9mIERhdGUgPyBhY2NvdW50LmNyZWF0ZWRBdC50b0lTT1N0cmluZygpIDogYWNjb3VudC5jcmVhdGVkQXQsXHJcbiAgICB1cGRhdGVkQXQ6IGFjY291bnQudXBkYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSA/IGFjY291bnQudXBkYXRlZEF0LnRvSVNPU3RyaW5nKCkgOiBhY2NvdW50LnVwZGF0ZWRBdCxcclxuICAgIGxhc3RUcmFuc2FjdGlvbkRhdGU6IGFjY291bnQubGFzdFRyYW5zYWN0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBhY2NvdW50Lmxhc3RUcmFuc2FjdGlvbkRhdGUudG9JU09TdHJpbmcoKSA6IGFjY291bnQubGFzdFRyYW5zYWN0aW9uRGF0ZSxcclxuICB9KSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldENyZWRpdEFjY291bnRCeU5hbWUoY3VzdG9tZXJOYW1lKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3QgYWNjb3VudCA9IGF3YWl0IGRiLmNvbGxlY3Rpb24oJ2NyZWRpdEFjY291bnRzJykuZmluZE9uZSh7IFxyXG4gICAgY3VzdG9tZXJOYW1lOiB7ICRyZWdleDogbmV3IFJlZ0V4cCgnXicgKyBjdXN0b21lck5hbWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSArICckJywgJ2knKSB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgaWYgKCFhY2NvdW50KSByZXR1cm4gbnVsbDtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgLi4uYWNjb3VudCxcclxuICAgIGlkOiBhY2NvdW50Ll9pZC50b1N0cmluZygpLFxyXG4gICAgY3JlYXRlZEF0OiBhY2NvdW50LmNyZWF0ZWRBdCBpbnN0YW5jZW9mIERhdGUgPyBhY2NvdW50LmNyZWF0ZWRBdC50b0lTT1N0cmluZygpIDogYWNjb3VudC5jcmVhdGVkQXQsXHJcbiAgICB1cGRhdGVkQXQ6IGFjY291bnQudXBkYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSA/IGFjY291bnQudXBkYXRlZEF0LnRvSVNPU3RyaW5nKCkgOiBhY2NvdW50LnVwZGF0ZWRBdCxcclxuICAgIGxhc3RUcmFuc2FjdGlvbkRhdGU6IGFjY291bnQubGFzdFRyYW5zYWN0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBhY2NvdW50Lmxhc3RUcmFuc2FjdGlvbkRhdGUudG9JU09TdHJpbmcoKSA6IGFjY291bnQubGFzdFRyYW5zYWN0aW9uRGF0ZSxcclxuICB9O1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiB1cHNlcnRDcmVkaXRBY2NvdW50KGFjY291bnREYXRhKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3QgeyBPYmplY3RJZCB9ID0gcmVxdWlyZSgnbW9uZ29kYicpO1xyXG4gIFxyXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgY29uc3QgY3VzdG9tZXJOYW1lID0gYWNjb3VudERhdGEuY3VzdG9tZXJOYW1lPy50cmltKCk7XHJcbiAgXHJcbiAgaWYgKCFjdXN0b21lck5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQ3VzdG9tZXIgbmFtZSBpcyByZXF1aXJlZCcpO1xyXG4gIH1cclxuICBcclxuICAvLyBGaW5kIGV4aXN0aW5nIGFjY291bnQgKGNhc2UtaW5zZW5zaXRpdmUpXHJcbiAgY29uc3QgZXhpc3RpbmdBY2NvdW50ID0gYXdhaXQgZGIuY29sbGVjdGlvbignY3JlZGl0QWNjb3VudHMnKS5maW5kT25lKHtcclxuICAgIGN1c3RvbWVyTmFtZTogeyAkcmVnZXg6IG5ldyBSZWdFeHAoJ14nICsgY3VzdG9tZXJOYW1lLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykgKyAnJCcsICdpJykgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIGlmIChleGlzdGluZ0FjY291bnQpIHtcclxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhY2NvdW50XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0ge1xyXG4gICAgICBiYWxhbmNlOiBOdW1iZXIoYWNjb3VudERhdGEuYmFsYW5jZSB8fCBleGlzdGluZ0FjY291bnQuYmFsYW5jZSB8fCAwKSxcclxuICAgICAgcGhvbmU6IGFjY291bnREYXRhLnBob25lIHx8IGV4aXN0aW5nQWNjb3VudC5waG9uZSB8fCAnJyxcclxuICAgICAgZW1haWw6IGFjY291bnREYXRhLmVtYWlsIHx8IGV4aXN0aW5nQWNjb3VudC5lbWFpbCB8fCAnJyxcclxuICAgICAgYWRkcmVzczogYWNjb3VudERhdGEuYWRkcmVzcyB8fCBleGlzdGluZ0FjY291bnQuYWRkcmVzcyB8fCAnJyxcclxuICAgICAgbm90ZXM6IGFjY291bnREYXRhLm5vdGVzIHx8IGV4aXN0aW5nQWNjb3VudC5ub3RlcyB8fCAnJyxcclxuICAgICAgaXNBY3RpdmU6IGFjY291bnREYXRhLmlzQWN0aXZlICE9PSB1bmRlZmluZWQgPyBhY2NvdW50RGF0YS5pc0FjdGl2ZSA6IGV4aXN0aW5nQWNjb3VudC5pc0FjdGl2ZSxcclxuICAgICAgdXBkYXRlZEF0OiBub3dcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBsYXN0IHRyYW5zYWN0aW9uIGRhdGUgaWYgcHJvdmlkZWRcclxuICAgIGlmIChhY2NvdW50RGF0YS5sYXN0VHJhbnNhY3Rpb25EYXRlKSB7XHJcbiAgICAgIHVwZGF0ZURhdGEubGFzdFRyYW5zYWN0aW9uRGF0ZSA9IGFjY291bnREYXRhLmxhc3RUcmFuc2FjdGlvbkRhdGUgaW5zdGFuY2VvZiBEYXRlID8gXHJcbiAgICAgICAgYWNjb3VudERhdGEubGFzdFRyYW5zYWN0aW9uRGF0ZSA6IG5ldyBEYXRlKGFjY291bnREYXRhLmxhc3RUcmFuc2FjdGlvbkRhdGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgdHJhbnNhY3Rpb24gY291bnQgaWYgcHJvdmlkZWRcclxuICAgIGlmIChhY2NvdW50RGF0YS50cmFuc2FjdGlvbkNvdW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdXBkYXRlRGF0YS50cmFuc2FjdGlvbkNvdW50ID0gTnVtYmVyKGFjY291bnREYXRhLnRyYW5zYWN0aW9uQ291bnQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjcmVkaXRBY2NvdW50cycpLnVwZGF0ZU9uZShcclxuICAgICAgeyBfaWQ6IGV4aXN0aW5nQWNjb3VudC5faWQgfSxcclxuICAgICAgeyAkc2V0OiB1cGRhdGVEYXRhIH1cclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmIChyZXN1bHQubW9kaWZpZWRDb3VudCA+IDApIHtcclxuICAgICAgY29uc3QgdXBkYXRlZEFjY291bnQgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjcmVkaXRBY2NvdW50cycpLmZpbmRPbmUoeyBfaWQ6IGV4aXN0aW5nQWNjb3VudC5faWQgfSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4udXBkYXRlZEFjY291bnQsXHJcbiAgICAgICAgaWQ6IHVwZGF0ZWRBY2NvdW50Ll9pZC50b1N0cmluZygpLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5leGlzdGluZ0FjY291bnQsXHJcbiAgICAgIGlkOiBleGlzdGluZ0FjY291bnQuX2lkLnRvU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBDcmVhdGUgbmV3IGFjY291bnRcclxuICAgIGNvbnN0IG5ld0FjY291bnQgPSB7XHJcbiAgICAgIGN1c3RvbWVyTmFtZTogY3VzdG9tZXJOYW1lLFxyXG4gICAgICBiYWxhbmNlOiBOdW1iZXIoYWNjb3VudERhdGEuYmFsYW5jZSB8fCAwKSxcclxuICAgICAgcGhvbmU6IGFjY291bnREYXRhLnBob25lIHx8ICcnLFxyXG4gICAgICBlbWFpbDogYWNjb3VudERhdGEuZW1haWwgfHwgJycsXHJcbiAgICAgIGFkZHJlc3M6IGFjY291bnREYXRhLmFkZHJlc3MgfHwgJycsXHJcbiAgICAgIG5vdGVzOiBhY2NvdW50RGF0YS5ub3RlcyB8fCAnJyxcclxuICAgICAgaXNBY3RpdmU6IGFjY291bnREYXRhLmlzQWN0aXZlICE9PSB1bmRlZmluZWQgPyBhY2NvdW50RGF0YS5pc0FjdGl2ZSA6IHRydWUsXHJcbiAgICAgIHRyYW5zYWN0aW9uQ291bnQ6IE51bWJlcihhY2NvdW50RGF0YS50cmFuc2FjdGlvbkNvdW50IHx8IDApLFxyXG4gICAgICBjcmVhdGVkQXQ6IG5vdyxcclxuICAgICAgdXBkYXRlZEF0OiBub3csXHJcbiAgICAgIGxhc3RUcmFuc2FjdGlvbkRhdGU6IGFjY291bnREYXRhLmxhc3RUcmFuc2FjdGlvbkRhdGUgPyBcclxuICAgICAgICAoYWNjb3VudERhdGEubGFzdFRyYW5zYWN0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBhY2NvdW50RGF0YS5sYXN0VHJhbnNhY3Rpb25EYXRlIDogbmV3IERhdGUoYWNjb3VudERhdGEubGFzdFRyYW5zYWN0aW9uRGF0ZSkpIFxyXG4gICAgICAgIDogbm93XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjcmVkaXRBY2NvdW50cycpLmluc2VydE9uZShuZXdBY2NvdW50KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4ubmV3QWNjb3VudCxcclxuICAgICAgaWQ6IHJlc3VsdC5pbnNlcnRlZElkLnRvU3RyaW5nKCksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gYWRkVG9DcmVkaXRBY2NvdW50KGN1c3RvbWVyTmFtZSwgYW1vdW50LCB0cmFuc2FjdGlvbklkID0gbnVsbCkge1xyXG4gIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gIFxyXG4gIC8vIEdldCBvciBjcmVhdGUgYWNjb3VudFxyXG4gIGxldCBhY2NvdW50ID0gYXdhaXQgZ2V0Q3JlZGl0QWNjb3VudEJ5TmFtZShjdXN0b21lck5hbWUpO1xyXG4gIFxyXG4gIGlmICghYWNjb3VudCkge1xyXG4gICAgLy8gQ3JlYXRlIG5ldyBhY2NvdW50IGlmIGl0IGRvZXNuJ3QgZXhpc3RcclxuICAgIGFjY291bnQgPSBhd2FpdCB1cHNlcnRDcmVkaXRBY2NvdW50KHtcclxuICAgICAgY3VzdG9tZXJOYW1lOiBjdXN0b21lck5hbWUsXHJcbiAgICAgIGJhbGFuY2U6IGFtb3VudCxcclxuICAgICAgdHJhbnNhY3Rpb25Db3VudDogMSxcclxuICAgICAgbGFzdFRyYW5zYWN0aW9uRGF0ZTogbmV3IERhdGUoKVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhY2NvdW50XHJcbiAgICBjb25zdCBuZXdCYWxhbmNlID0gTnVtYmVyKGFjY291bnQuYmFsYW5jZSB8fCAwKSArIE51bWJlcihhbW91bnQpO1xyXG4gICAgY29uc3QgbmV3VHJhbnNhY3Rpb25Db3VudCA9IE51bWJlcihhY2NvdW50LnRyYW5zYWN0aW9uQ291bnQgfHwgMCkgKyAxO1xyXG4gICAgXHJcbiAgICBhY2NvdW50ID0gYXdhaXQgdXBzZXJ0Q3JlZGl0QWNjb3VudCh7XHJcbiAgICAgIGN1c3RvbWVyTmFtZTogY3VzdG9tZXJOYW1lLFxyXG4gICAgICBiYWxhbmNlOiBuZXdCYWxhbmNlLFxyXG4gICAgICB0cmFuc2FjdGlvbkNvdW50OiBuZXdUcmFuc2FjdGlvbkNvdW50LFxyXG4gICAgICBsYXN0VHJhbnNhY3Rpb25EYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgICBwaG9uZTogYWNjb3VudC5waG9uZSxcclxuICAgICAgZW1haWw6IGFjY291bnQuZW1haWwsXHJcbiAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyxcclxuICAgICAgbm90ZXM6IGFjY291bnQubm90ZXMsXHJcbiAgICAgIGlzQWN0aXZlOiBhY2NvdW50LmlzQWN0aXZlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGFjY291bnQ7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHBheVRvQ3JlZGl0QWNjb3VudChjdXN0b21lck5hbWUsIHBheW1lbnRBbW91bnQpIHtcclxuICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICBcclxuICBjb25zdCBhY2NvdW50ID0gYXdhaXQgZ2V0Q3JlZGl0QWNjb3VudEJ5TmFtZShjdXN0b21lck5hbWUpO1xyXG4gIGlmICghYWNjb3VudCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkaXQgYWNjb3VudCBub3QgZm91bmQnKTtcclxuICB9XHJcbiAgXHJcbiAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBOdW1iZXIoYWNjb3VudC5iYWxhbmNlIHx8IDApO1xyXG4gIGNvbnN0IHBheW1lbnQgPSBOdW1iZXIocGF5bWVudEFtb3VudCk7XHJcbiAgXHJcbiAgaWYgKHBheW1lbnQgPiBjdXJyZW50QmFsYW5jZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGFtb3VudCBleGNlZWRzIGFjY291bnQgYmFsYW5jZScpO1xyXG4gIH1cclxuICBcclxuICBjb25zdCBuZXdCYWxhbmNlID0gY3VycmVudEJhbGFuY2UgLSBwYXltZW50O1xyXG4gIFxyXG4gIGNvbnN0IHVwZGF0ZWRBY2NvdW50ID0gYXdhaXQgdXBzZXJ0Q3JlZGl0QWNjb3VudCh7XHJcbiAgICBjdXN0b21lck5hbWU6IGN1c3RvbWVyTmFtZSxcclxuICAgIGJhbGFuY2U6IG5ld0JhbGFuY2UsXHJcbiAgICB0cmFuc2FjdGlvbkNvdW50OiBhY2NvdW50LnRyYW5zYWN0aW9uQ291bnQsXHJcbiAgICBsYXN0VHJhbnNhY3Rpb25EYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgcGhvbmU6IGFjY291bnQucGhvbmUsXHJcbiAgICBlbWFpbDogYWNjb3VudC5lbWFpbCxcclxuICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyxcclxuICAgIG5vdGVzOiBhY2NvdW50Lm5vdGVzLFxyXG4gICAgaXNBY3RpdmU6IGFjY291bnQuaXNBY3RpdmVcclxuICB9KTtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgLi4udXBkYXRlZEFjY291bnQsXHJcbiAgICBwYXltZW50QW1vdW50OiBwYXltZW50LFxyXG4gICAgcHJldmlvdXNCYWxhbmNlOiBjdXJyZW50QmFsYW5jZSxcclxuICAgIG5ld0JhbGFuY2U6IG5ld0JhbGFuY2VcclxuICB9O1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBkZWxldGVDcmVkaXRBY2NvdW50KGlkKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgY29uc3QgeyBPYmplY3RJZCB9ID0gcmVxdWlyZSgnbW9uZ29kYicpO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBvYmplY3RJZCA9IG5ldyBPYmplY3RJZChpZCk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdjcmVkaXRBY2NvdW50cycpLmRlbGV0ZU9uZSh7IF9pZDogb2JqZWN0SWQgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LmRlbGV0ZWRDb3VudCA+IDA7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGNyZWRpdCBhY2NvdW50OicsIGVycm9yKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlYXJjaENyZWRpdEFjY291bnRzKHNlYXJjaFRlcm0sIGluY2x1ZGVJbmFjdGl2ZSA9IGZhbHNlKSB7XHJcbiAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgXHJcbiAgY29uc3QgcXVlcnkgPSB7XHJcbiAgICBjdXN0b21lck5hbWU6IHsgJHJlZ2V4OiBzZWFyY2hUZXJtLCAkb3B0aW9uczogJ2knIH1cclxuICB9O1xyXG4gIFxyXG4gIGlmICghaW5jbHVkZUluYWN0aXZlKSB7XHJcbiAgICBxdWVyeS5pc0FjdGl2ZSA9IHsgJG5lOiBmYWxzZSB9O1xyXG4gIH1cclxuICBcclxuICBjb25zdCBjdXJzb3IgPSBkYi5jb2xsZWN0aW9uKCdjcmVkaXRBY2NvdW50cycpLmZpbmQocXVlcnkpLnNvcnQoeyBiYWxhbmNlOiAtMSwgbGFzdFRyYW5zYWN0aW9uRGF0ZTogLTEgfSk7XHJcbiAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBjdXJzb3IudG9BcnJheSgpO1xyXG4gIFxyXG4gIHJldHVybiBhY2NvdW50cy5tYXAoKGFjY291bnQpID0+ICh7XHJcbiAgICAuLi5hY2NvdW50LFxyXG4gICAgaWQ6IGFjY291bnQuX2lkLnRvU3RyaW5nKCksXHJcbiAgICBjcmVhdGVkQXQ6IGFjY291bnQuY3JlYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSA/IGFjY291bnQuY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCkgOiBhY2NvdW50LmNyZWF0ZWRBdCxcclxuICAgIHVwZGF0ZWRBdDogYWNjb3VudC51cGRhdGVkQXQgaW5zdGFuY2VvZiBEYXRlID8gYWNjb3VudC51cGRhdGVkQXQudG9JU09TdHJpbmcoKSA6IGFjY291bnQudXBkYXRlZEF0LFxyXG4gICAgbGFzdFRyYW5zYWN0aW9uRGF0ZTogYWNjb3VudC5sYXN0VHJhbnNhY3Rpb25EYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGFjY291bnQubGFzdFRyYW5zYWN0aW9uRGF0ZS50b0lTT1N0cmluZygpIDogYWNjb3VudC5sYXN0VHJhbnNhY3Rpb25EYXRlLFxyXG4gIH0pKTtcclxufVxyXG5cclxuLy8gVGlsbCBDb3VudCBNYW5hZ2VtZW50IEZ1bmN0aW9uc1xyXG5hc3luYyBmdW5jdGlvbiBnZXRDdXJyZW50VGlsbCgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGIgPSBhd2FpdCBjb25uZWN0KCk7XHJcbiAgICBjb25zdCB0aWxsQ29sbGVjdGlvbiA9IGRiLmNvbGxlY3Rpb24oJ3RpbGxDb3VudHMnKTtcclxuICAgIFxyXG4gICAgLy8gRmluZCB0aGUgbW9zdCByZWNlbnQgb3BlbiB0aWxsIChubyBlbmRUaW1lKVxyXG4gICAgY29uc3QgY3VycmVudFRpbGwgPSBhd2FpdCB0aWxsQ29sbGVjdGlvbi5maW5kT25lKFxyXG4gICAgICB7IGVuZFRpbWU6IG51bGwgfSxcclxuICAgICAgeyBzb3J0OiB7IHN0YXJ0VGltZTogLTEgfSB9XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICByZXR1cm4gY3VycmVudFRpbGw7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgY3VycmVudCB0aWxsOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VGlsbEhpc3RvcnkobGltaXQgPSAyMCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICAgIGNvbnN0IHRpbGxDb2xsZWN0aW9uID0gZGIuY29sbGVjdGlvbigndGlsbENvdW50cycpO1xyXG4gICAgXHJcbiAgICBjb25zdCBoaXN0b3J5ID0gYXdhaXQgdGlsbENvbGxlY3Rpb25cclxuICAgICAgLmZpbmQoe30pXHJcbiAgICAgIC5zb3J0KHsgc3RhcnRUaW1lOiAtMSB9KVxyXG4gICAgICAubGltaXQobGltaXQpXHJcbiAgICAgIC50b0FycmF5KCk7XHJcbiAgICBcclxuICAgIHJldHVybiBoaXN0b3J5O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHRpbGwgaGlzdG9yeTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0VGlsbCh0aWxsRGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBkYiA9IGF3YWl0IGNvbm5lY3QoKTtcclxuICAgIGNvbnN0IHRpbGxDb2xsZWN0aW9uID0gZGIuY29sbGVjdGlvbigndGlsbENvdW50cycpO1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBhIHNpbXBsZSBJRFxyXG4gICAgY29uc3QgZ2VuZXJhdGVJZCA9ICgpID0+IERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcclxuICAgIFxyXG4gICAgY29uc3QgdGlsbCA9IHtcclxuICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcclxuICAgICAgc3RhcnRBbW91bnQ6IHRpbGxEYXRhLnN0YXJ0QW1vdW50LFxyXG4gICAgICBzdGFydFVzZXI6IHRpbGxEYXRhLnN0YXJ0VXNlcixcclxuICAgICAgc3RhcnRUaW1lOiB0aWxsRGF0YS5zdGFydFRpbWUsXHJcbiAgICAgIHN0YXJ0RGVub21pbmF0aW9uczogdGlsbERhdGEuc3RhcnREZW5vbWluYXRpb25zIHx8IHt9LFxyXG4gICAgICBlbmRBbW91bnQ6IG51bGwsXHJcbiAgICAgIGVuZFVzZXI6IG51bGwsXHJcbiAgICAgIGVuZFRpbWU6IG51bGwsXHJcbiAgICAgIGVuZERlbm9taW5hdGlvbnM6IG51bGwsXHJcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhd2FpdCB0aWxsQ29sbGVjdGlvbi5pbnNlcnRPbmUodGlsbCk7XHJcbiAgICByZXR1cm4gdGlsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3RhcnRpbmcgdGlsbDonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGVuZFRpbGwodGlsbElkLCBlbmREYXRhKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGRiID0gYXdhaXQgY29ubmVjdCgpO1xyXG4gICAgY29uc3QgdGlsbENvbGxlY3Rpb24gPSBkYi5jb2xsZWN0aW9uKCd0aWxsQ291bnRzJyk7XHJcbiAgICBcclxuICAgIGNvbnN0IHVwZGF0ZVJlc3VsdCA9IGF3YWl0IHRpbGxDb2xsZWN0aW9uLnVwZGF0ZU9uZShcclxuICAgICAgeyBpZDogdGlsbElkIH0sXHJcbiAgICAgIHtcclxuICAgICAgICAkc2V0OiB7XHJcbiAgICAgICAgICBlbmRBbW91bnQ6IGVuZERhdGEuZW5kQW1vdW50LFxyXG4gICAgICAgICAgZW5kVXNlcjogZW5kRGF0YS5lbmRVc2VyLFxyXG4gICAgICAgICAgZW5kVGltZTogZW5kRGF0YS5lbmRUaW1lLFxyXG4gICAgICAgICAgZW5kRGVub21pbmF0aW9uczogZW5kRGF0YS5lbmREZW5vbWluYXRpb25zIHx8IHt9LFxyXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmICh1cGRhdGVSZXN1bHQubWF0Y2hlZENvdW50ID09PSAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGlsbCBub3QgZm91bmQnKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdXBkYXRlZFRpbGwgPSBhd2FpdCB0aWxsQ29sbGVjdGlvbi5maW5kT25lKHsgaWQ6IHRpbGxJZCB9KTtcclxuICAgIHJldHVybiB1cGRhdGVkVGlsbDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5kaW5nIHRpbGw6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBjb25uZWN0LFxyXG4gIGdldEFsbEludmVudG9yeSxcclxuICBnZXRJbnZlbnRvcnlCeUlkLFxyXG4gIHVwc2VydEludmVudG9yeUl0ZW1zLFxyXG4gIGRlbGV0ZUludmVudG9yeUJ5SWQsXHJcbiAgZ2V0VXNlcnMsXHJcbiAgZ2V0VXNlckJ5VXNlcm5hbWUsXHJcbiAgdXBzZXJ0VXNlcixcclxuICByZXBsYWNlQWxsVXNlcnMsXHJcbiAgZGVsZXRlVXNlckJ5SWQsXHJcbiAgc2F2ZVRyYW5zYWN0aW9uLFxyXG4gIGdldFRyYW5zYWN0aW9ucyxcclxuICBkZWxldGVUcmFuc2FjdGlvbixcclxuICBnZXRDYXRlZ29yaWVzLFxyXG4gIHNhdmVDYXRlZ29yeSxcclxuICBkZWxldGVDYXRlZ29yeSxcclxuICBnZXRDcmVkaXRBY2NvdW50cyxcclxuICBnZXRDcmVkaXRBY2NvdW50QnlOYW1lLFxyXG4gIHVwc2VydENyZWRpdEFjY291bnQsXHJcbiAgYWRkVG9DcmVkaXRBY2NvdW50LFxyXG4gIHBheVRvQ3JlZGl0QWNjb3VudCxcclxuICBkZWxldGVDcmVkaXRBY2NvdW50LFxyXG4gIHNlYXJjaENyZWRpdEFjY291bnRzLFxyXG4gIGdldEN1cnJlbnRUaWxsLFxyXG4gIGdldFRpbGxIaXN0b3J5LFxyXG4gIHN0YXJ0VGlsbCxcclxuICBlbmRUaWxsXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJNb25nb0NsaWVudCIsInJlcXVpcmUiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTU9OR09fVVJJIiwiZGJOYW1lIiwiTU9OR09fREIiLCJfY2xpZW50IiwiX2RiIiwiY29ubmVjdCIsInVzZVVuaWZpZWRUb3BvbG9neSIsImRiIiwiY29sbGVjdGlvbiIsImNyZWF0ZUluZGV4IiwiaWQiLCJ1bmlxdWUiLCJzcGFyc2UiLCJ1c2VybmFtZSIsImUiLCJnZXRBbGxJbnZlbnRvcnkiLCJmaW5kIiwic29ydCIsIm5hbWUiLCJ0b0FycmF5IiwiZ2V0SW52ZW50b3J5QnlJZCIsIm4iLCJOdW1iZXIiLCJmaW5kT25lIiwidXBzZXJ0SW52ZW50b3J5SXRlbXMiLCJpdGVtcyIsIkFycmF5IiwiaXNBcnJheSIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJvcHMiLCJtYXAiLCJpdCIsImluZGV4IiwiSlNPTiIsInN0cmluZ2lmeSIsIml0ZW1JZCIsInVuZGVmaW5lZCIsImlzTmFOIiwiZXJyb3IiLCJFcnJvciIsIm9iaiIsImNhdGVnb3J5IiwicHJpY2UiLCJzdG9jayIsImxvd1N0b2NrVGhyZXNob2xkIiwidGF4YWJsZSIsImJhcmNvZGUiLCJ0b1N0cmluZyIsImJhcmNvZGUyIiwicHJvZHVjdElkIiwiZmlsdGVyIiwidXBkYXRlT25lIiwidXBkYXRlIiwiJHNldCIsInVwc2VydCIsInJlc3VsdCIsImJ1bGtXcml0ZSIsImNvZGUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJpIiwiaXRlbSIsIml0ZW1XaXRoVW5pcXVlUHJvZHVjdElkIiwiRGF0ZSIsIm5vdyIsImluZGl2aWR1YWxFcnJvciIsImRlbGV0ZUludmVudG9yeUJ5SWQiLCJkZWxldGVPbmUiLCJnZXRVc2VycyIsInVzZXJzIiwiZGVmYXVsdFVzZXJzIiwicHdkIiwicm9sZSIsImVtYWlsIiwiYWN0aXZlIiwicGVybWlzc2lvbnNfanNvbiIsImludmVudG9yeSIsInJlcG9ydHMiLCJwb3MiLCJ0cmFuc2FjdGlvbnMiLCJtYW5hZ2VVc2VycyIsIm1hbmFnZUludmVudG9yeSIsIm1hbmFnZVJlcG9ydHMiLCJtYW5hZ2VQT1MiLCJpbnNlcnRNYW55IiwibmV3VXNlcnMiLCJ1c2VyIiwicGFzc3dvcmQiLCJnZXRVc2VyQnlVc2VybmFtZSIsInVwc2VydFVzZXIiLCJib2R5IiwicGVybWlzc2lvbnMiLCJyZXBsYWNlQWxsVXNlcnMiLCJkZWxldGVNYW55IiwiZm9ybWF0dGVkVXNlcnMiLCJkZWxldGVVc2VyQnlJZCIsInNhdmVUcmFuc2FjdGlvbiIsInR4T2JqIiwicGF5bWVudEJyZWFrZG93biIsInBheW1lbnQiLCJ0cmFuc2FjdGlvblR5cGUiLCJjYXNoQW1vdW50IiwiY2FyZEFtb3VudCIsImNyZWRpdEFtb3VudCIsImhhc0xvdHRvIiwiZm9yRWFjaCIsImFtb3VudCIsIm1ldGhvZCIsInRvTG93ZXJDYXNlIiwiZG9jIiwibGVnYWN5X2lkIiwidGltZXN0YW1wIiwic3VidG90YWwiLCJ0YXhhYmxlQW1vdW50Iiwibm9uVGF4YWJsZUFtb3VudCIsInRheCIsInRvdGFsIiwiY2FzaGJhY2siLCJjaGFuZ2UiLCJwcm9kdWN0X2lkIiwicXVhbnRpdHkiLCJhcHBseVRheCIsInJlcyIsImluc2VydE9uZSIsImluc2VydGVkSWQiLCJjdXIiLCJuZXdTdG9jayIsImdldFRyYW5zYWN0aW9ucyIsImxpbWl0IiwiY3Vyc29yIiwiX2lkIiwicm93cyIsInIiLCJ0b0lTT1N0cmluZyIsImRlbGV0ZVRyYW5zYWN0aW9uIiwiT2JqZWN0SWQiLCJvYmplY3RJZCIsImRlbGV0ZWRDb3VudCIsImdldENhdGVnb3JpZXMiLCJjYXRlZ29yaWVzIiwiZGVmYXVsdENhdGVnb3JpZXMiLCJkZXNjcmlwdGlvbiIsInNhdmVDYXRlZ29yeSIsInVwZGF0ZWRBdCIsImxhc3RDYXRlZ29yeSIsIm5leHRJZCIsIm5ld0NhdGVnb3J5IiwiY3JlYXRlZEF0IiwiZGVsZXRlQ2F0ZWdvcnkiLCJnZXRDcmVkaXRBY2NvdW50cyIsImxhc3RUcmFuc2FjdGlvbkRhdGUiLCJhY2NvdW50cyIsImFjY291bnQiLCJnZXRDcmVkaXRBY2NvdW50QnlOYW1lIiwiY3VzdG9tZXJOYW1lIiwiJHJlZ2V4IiwiUmVnRXhwIiwicmVwbGFjZSIsInVwc2VydENyZWRpdEFjY291bnQiLCJhY2NvdW50RGF0YSIsInRyaW0iLCJleGlzdGluZ0FjY291bnQiLCJ1cGRhdGVEYXRhIiwiYmFsYW5jZSIsInBob25lIiwiYWRkcmVzcyIsIm5vdGVzIiwiaXNBY3RpdmUiLCJ0cmFuc2FjdGlvbkNvdW50IiwibW9kaWZpZWRDb3VudCIsInVwZGF0ZWRBY2NvdW50IiwibmV3QWNjb3VudCIsImFkZFRvQ3JlZGl0QWNjb3VudCIsInRyYW5zYWN0aW9uSWQiLCJuZXdCYWxhbmNlIiwibmV3VHJhbnNhY3Rpb25Db3VudCIsInBheVRvQ3JlZGl0QWNjb3VudCIsInBheW1lbnRBbW91bnQiLCJjdXJyZW50QmFsYW5jZSIsInByZXZpb3VzQmFsYW5jZSIsImRlbGV0ZUNyZWRpdEFjY291bnQiLCJzZWFyY2hDcmVkaXRBY2NvdW50cyIsInNlYXJjaFRlcm0iLCJpbmNsdWRlSW5hY3RpdmUiLCJxdWVyeSIsIiRvcHRpb25zIiwiJG5lIiwiZ2V0Q3VycmVudFRpbGwiLCJ0aWxsQ29sbGVjdGlvbiIsImN1cnJlbnRUaWxsIiwiZW5kVGltZSIsInN0YXJ0VGltZSIsImdldFRpbGxIaXN0b3J5IiwiaGlzdG9yeSIsInN0YXJ0VGlsbCIsInRpbGxEYXRhIiwiZ2VuZXJhdGVJZCIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJ0aWxsIiwic3RhcnRBbW91bnQiLCJzdGFydFVzZXIiLCJzdGFydERlbm9taW5hdGlvbnMiLCJlbmRBbW91bnQiLCJlbmRVc2VyIiwiZW5kRGVub21pbmF0aW9ucyIsImVuZFRpbGwiLCJ0aWxsSWQiLCJlbmREYXRhIiwidXBkYXRlUmVzdWx0IiwibWF0Y2hlZENvdW50IiwidXBkYXRlZFRpbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./server/mongo.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcategories%2Froute&page=%2Fapi%2Fcategories%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcategories%2Froute.js&appDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cshop%5CDesktop%5CgptPos%5CgptPOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();